{"version":3,"sources":["../src/ruleset.ts","../node_modules/redos-detector/dist/redos-detector.es.js","../src/shared/checkForRedosError.ts","../src/functions/validateSchemaPropertyPatternRegex.ts","../node_modules/@stoplight/types/dist/index.mjs"],"sourcesContent":["import validateSchemaPropertyPatternRegex from \"./functions/validateSchemaPropertyPatternRegex\";\nimport { DiagnosticSeverity } from \"@stoplight/types\";\n\nexport default {\n  rules: {\n    \"unsafe-pattern-regex-components-schema-property\": {\n      description:\n        \"Check for possible ReDos regex patterns in components schemas properties\",\n      given: \"$.components.schemas..properties[*]\",\n      message: \"{{error}}\",\n      severity: DiagnosticSeverity.Error,\n      then: {\n        function: validateSchemaPropertyPatternRegex,\n      },\n    },\n    \"unsafe-pattern-regex-components-schema-array-property\": {\n      description:\n        \"Check for possible ReDos regex patterns in components schemas with array items that are not objects\",\n      given:\n        '$.components.schemas..properties[?(@ && @.type == \"array\" && @.items && @.items.properties == null)].items',\n      message: \"{{error}}\",\n      severity: DiagnosticSeverity.Error,\n      then: {\n        function: validateSchemaPropertyPatternRegex,\n      },\n    },\n    \"unsafe-pattern-regex-components-schema-array-object-property\": {\n      description:\n        \"Check for possible ReDos regex patterns in components schemas with array items that are objects\",\n      given:\n        '$.components.schemas..properties[?(@ && @.type==\"array\")].items.properties[*]',\n      message: \"{{error}}\",\n      severity: DiagnosticSeverity.Error,\n      then: {\n        function: validateSchemaPropertyPatternRegex,\n      },\n    },\n    \"unsafe-pattern-regex-components-headers-property\": {\n      description:\n        \"Check for possible ReDos regex patterns in components headers schemas\",\n      given: \"$.components.headers..schema\",\n      message: \"{{error}}\",\n      severity: DiagnosticSeverity.Error,\n      then: {\n        function: validateSchemaPropertyPatternRegex,\n      },\n    },\n    // \"unsafe-pattern-regex-path-parameter-property\": {\n    //   description: \"Check regex patterns in path parameters\",\n    //   given: \"$.paths.*.*.parameters[*].schema\",\n    //   message: \"{{error}}\",\n    //   severity: DiagnosticSeverity.Error,\n    //   then: {\n    //     function: validateSchemaPropertyPatternRegex,\n    //   },\n    // },\n  },\n};\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar parserExports = {};\nvar parser = {\n  get exports(){ return parserExports; },\n  set exports(v){ parserExports = v; },\n};\n\n(function (module) {\n\t(function() {\n\n\t  var fromCodePoint = String.fromCodePoint || (function() {\n\t    // Implementation taken from\n\t    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint\n\n\t    var stringFromCharCode = String.fromCharCode;\n\t    var floor = Math.floor;\n\n\t    return function fromCodePoint() {\n\t      var MAX_SIZE = 0x4000;\n\t      var codeUnits = [];\n\t      var highSurrogate;\n\t      var lowSurrogate;\n\t      var index = -1;\n\t      var length = arguments.length;\n\t      if (!length) {\n\t        return '';\n\t      }\n\t      var result = '';\n\t      while (++index < length) {\n\t        var codePoint = Number(arguments[index]);\n\t        if (\n\t          !isFinite(codePoint) ||       // `NaN`, `+Infinity`, or `-Infinity`\n\t          codePoint < 0 ||              // not a valid Unicode code point\n\t          codePoint > 0x10FFFF ||       // not a valid Unicode code point\n\t          floor(codePoint) != codePoint // not an integer\n\t        ) {\n\t          throw RangeError('Invalid code point: ' + codePoint);\n\t        }\n\t        if (codePoint <= 0xFFFF) { // BMP code point\n\t          codeUnits.push(codePoint);\n\t        } else { // Astral code point; split in surrogate halves\n\t          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t          codePoint -= 0x10000;\n\t          highSurrogate = (codePoint >> 10) + 0xD800;\n\t          lowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t          codeUnits.push(highSurrogate, lowSurrogate);\n\t        }\n\t        if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n\t          result += stringFromCharCode.apply(null, codeUnits);\n\t          codeUnits.length = 0;\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t  }());\n\n\t  function parse(str, flags, features) {\n\t    if (!features) {\n\t      features = {};\n\t    }\n\t    function addRaw(node) {\n\t      node.raw = str.substring(node.range[0], node.range[1]);\n\t      return node;\n\t    }\n\n\t    function updateRawStart(node, start) {\n\t      node.range[0] = start;\n\t      return addRaw(node);\n\t    }\n\n\t    function createAnchor(kind, rawLength) {\n\t      return addRaw({\n\t        type: 'anchor',\n\t        kind: kind,\n\t        range: [\n\t          pos - rawLength,\n\t          pos\n\t        ]\n\t      });\n\t    }\n\n\t    function createValue(kind, codePoint, from, to) {\n\t      return addRaw({\n\t        type: 'value',\n\t        kind: kind,\n\t        codePoint: codePoint,\n\t        range: [from, to]\n\t      });\n\t    }\n\n\t    function createEscaped(kind, codePoint, value, fromOffset) {\n\t      fromOffset = fromOffset || 0;\n\t      return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);\n\t    }\n\n\t    function createCharacter(matches) {\n\t      var _char = matches[0];\n\t      var first = _char.charCodeAt(0);\n\t      if (isUnicodeMode) {\n\t        var second;\n\t        if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {\n\t          second = lookahead().charCodeAt(0);\n\t          if (second >= 0xDC00 && second <= 0xDFFF) {\n\t            // Unicode surrogate pair\n\t            pos++;\n\t            return createValue(\n\t              'symbol',\n\t              (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000,\n\t              pos - 2, pos);\n\t          }\n\t        }\n\t      }\n\t      return createValue('symbol', first, pos - 1, pos);\n\t    }\n\n\t    function createDisjunction(alternatives, from, to) {\n\t      return addRaw({\n\t        type: 'disjunction',\n\t        body: alternatives,\n\t        range: [\n\t          from,\n\t          to\n\t        ]\n\t      });\n\t    }\n\n\t    function createDot() {\n\t      return addRaw({\n\t        type: 'dot',\n\t        range: [\n\t          pos - 1,\n\t          pos\n\t        ]\n\t      });\n\t    }\n\n\t    function createCharacterClassEscape(value) {\n\t      return addRaw({\n\t        type: 'characterClassEscape',\n\t        value: value,\n\t        range: [\n\t          pos - 2,\n\t          pos\n\t        ]\n\t      });\n\t    }\n\n\t    function createReference(matchIndex) {\n\t      return addRaw({\n\t        type: 'reference',\n\t        matchIndex: parseInt(matchIndex, 10),\n\t        range: [\n\t          pos - 1 - matchIndex.length,\n\t          pos\n\t        ]\n\t      });\n\t    }\n\n\t    function createNamedReference(name) {\n\t      return addRaw({\n\t        type: 'reference',\n\t        name: name,\n\t        range: [\n\t          name.range[0] - 3,\n\t          pos\n\t        ]\n\t      });\n\t    }\n\n\t    function createGroup(behavior, disjunction, from, to) {\n\t      return addRaw({\n\t        type: 'group',\n\t        behavior: behavior,\n\t        body: disjunction,\n\t        range: [\n\t          from,\n\t          to\n\t        ]\n\t      });\n\t    }\n\n\t    function createQuantifier(min, max, from, to, symbol) {\n\t      if (to == null) {\n\t        from = pos - 1;\n\t        to = pos;\n\t      }\n\n\t      return addRaw({\n\t        type: 'quantifier',\n\t        min: min,\n\t        max: max,\n\t        greedy: true,\n\t        body: null, // set later on\n\t        symbol: symbol,\n\t        range: [\n\t          from,\n\t          to\n\t        ]\n\t      });\n\t    }\n\n\t    function createAlternative(terms, from, to) {\n\t      return addRaw({\n\t        type: 'alternative',\n\t        body: terms,\n\t        range: [\n\t          from,\n\t          to\n\t        ]\n\t      });\n\t    }\n\n\t    function createCharacterClass(contents, negative, from, to) {\n\t      return addRaw({\n\t        type: 'characterClass',\n\t        kind: contents.kind,\n\t        body: contents.body,\n\t        negative: negative,\n\t        range: [\n\t          from,\n\t          to\n\t        ]\n\t      });\n\t    }\n\n\t    function createClassRange(min, max, from, to) {\n\t      // See 15.10.2.15:\n\t      if (min.codePoint > max.codePoint) {\n\t        bail('invalid range in character class', min.raw + '-' + max.raw, from, to);\n\t      }\n\n\t      return addRaw({\n\t        type: 'characterClassRange',\n\t        min: min,\n\t        max: max,\n\t        range: [\n\t          from,\n\t          to\n\t        ]\n\t      });\n\t    }\n\n\t    function createClassStrings(strings, from, to) {\n\t      return addRaw({\n\t        type: 'classStrings',\n\t        strings: strings,\n\t        range: [from, to]\n\t      });\n\t    }\n\n\t    function createClassString(characters, from, to) {\n\t      return addRaw({\n\t        type: 'classString',\n\t        characters: characters,\n\t        range: [from, to]\n\t      });\n\t    }\n\n\t    function flattenBody(body) {\n\t      if (body.type === 'alternative') {\n\t        return body.body;\n\t      } else {\n\t        return [body];\n\t      }\n\t    }\n\n\t    function incr(amount) {\n\t      amount = (amount || 1);\n\t      var res = str.substring(pos, pos + amount);\n\t      pos += (amount || 1);\n\t      return res;\n\t    }\n\n\t    function skip(value) {\n\t      if (!match(value)) {\n\t        bail('character', value);\n\t      }\n\t    }\n\n\t    function match(value) {\n\t      if (str.indexOf(value, pos) === pos) {\n\t        return incr(value.length);\n\t      }\n\t    }\n\n\t    function lookahead() {\n\t      return str[pos];\n\t    }\n\n\t    function current(value) {\n\t      return str.indexOf(value, pos) === pos;\n\t    }\n\n\t    function next(value) {\n\t      return str[pos + 1] === value;\n\t    }\n\n\t    function matchReg(regExp) {\n\t      var subStr = str.substring(pos);\n\t      var res = subStr.match(regExp);\n\t      if (res) {\n\t        res.range = [];\n\t        res.range[0] = pos;\n\t        incr(res[0].length);\n\t        res.range[1] = pos;\n\t      }\n\t      return res;\n\t    }\n\n\t    function parseDisjunction() {\n\t      // Disjunction ::\n\t      //      Alternative\n\t      //      Alternative | Disjunction\n\t      var res = [], from = pos;\n\t      res.push(parseAlternative());\n\n\t      while (match('|')) {\n\t        res.push(parseAlternative());\n\t      }\n\n\t      if (res.length === 1) {\n\t        return res[0];\n\t      }\n\n\t      return createDisjunction(res, from, pos);\n\t    }\n\n\t    function parseAlternative() {\n\t      var res = [], from = pos;\n\t      var term;\n\n\t      // Alternative ::\n\t      //      [empty]\n\t      //      Alternative Term\n\t      while (term = parseTerm()) {\n\t        res.push(term);\n\t      }\n\n\t      if (res.length === 1) {\n\t        return res[0];\n\t      }\n\n\t      return createAlternative(res, from, pos);\n\t    }\n\n\t    function parseTerm() {\n\t      // Term ::\n\t      //      Anchor\n\t      //      Atom\n\t      //      Atom Quantifier\n\n\t      if (pos >= str.length || current('|') || current(')')) {\n\t        return null; /* Means: The term is empty */\n\t      }\n\n\t      var anchor = parseAnchor();\n\n\t      if (anchor) {\n\t        return anchor;\n\t      }\n\n\t      var atom = parseAtomAndExtendedAtom();\n\t      var quantifier;\n\t      if (!atom) {\n\t        // Check if a quantifier is following. A quantifier without an atom\n\t        // is an error.\n\t        var pos_backup = pos;\n\t        quantifier = parseQuantifier() || false;\n\t        if (quantifier) {\n\t          pos = pos_backup;\n\t          bail('Expected atom');\n\t        }\n\n\t        // If no unicode flag, then try to parse ExtendedAtom -> ExtendedPatternCharacter.\n\t        //      ExtendedPatternCharacter\n\t        var res;\n\t        if (!isUnicodeMode && (res = matchReg(/^{/))) {\n\t          atom = createCharacter(res);\n\t        } else {\n\t          bail('Expected atom');\n\t        }\n\t      }\n\t      quantifier = parseQuantifier() || false;\n\t      if (quantifier) {\n\t        quantifier.body = flattenBody(atom);\n\t        // The quantifier contains the atom. Therefore, the beginning of the\n\t        // quantifier range is given by the beginning of the atom.\n\t        updateRawStart(quantifier, atom.range[0]);\n\t        return quantifier;\n\t      }\n\t      return atom;\n\t    }\n\n\t    function parseGroup(matchA, typeA, matchB, typeB) {\n\t      var type = null, from = pos;\n\n\t      if (match(matchA)) {\n\t        type = typeA;\n\t      } else if (match(matchB)) {\n\t        type = typeB;\n\t      } else {\n\t        return false;\n\t      }\n\n\t      return finishGroup(type, from);\n\t    }\n\n\t    function finishGroup(type, from) {\n\t      var body = parseDisjunction();\n\t      if (!body) {\n\t        bail('Expected disjunction');\n\t      }\n\t      skip(')');\n\t      var group = createGroup(type, flattenBody(body), from, pos);\n\n\t      if (type == 'normal') {\n\t        // Keep track of the number of closed groups. This is required for\n\t        // parseDecimalEscape(). In case the string is parsed a second time the\n\t        // value already holds the total count and no incrementation is required.\n\t        if (firstIteration) {\n\t          closedCaptureCounter++;\n\t        }\n\t      }\n\t      return group;\n\t    }\n\n\t    function parseAnchor() {\n\t      // Anchor ::\n\t      //      ^\n\t      //      $\n\t      //      \\ b\n\t      //      \\ B\n\t      //      ( ? = Disjunction )\n\t      //      ( ? ! Disjunction )\n\n\t      if (match('^')) {\n\t        return createAnchor('start', 1 /* rawLength */);\n\t      } else if (match('$')) {\n\t        return createAnchor('end', 1 /* rawLength */);\n\t      } else if (match('\\\\b')) {\n\t        return createAnchor('boundary', 2 /* rawLength */);\n\t      } else if (match('\\\\B')) {\n\t        return createAnchor('not-boundary', 2 /* rawLength */);\n\t      } else {\n\t        return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');\n\t      }\n\t    }\n\n\t    function parseQuantifier() {\n\t      // Quantifier ::\n\t      //      QuantifierPrefix\n\t      //      QuantifierPrefix ?\n\t      //\n\t      // QuantifierPrefix ::\n\t      //      *\n\t      //      +\n\t      //      ?\n\t      //      { DecimalDigits }\n\t      //      { DecimalDigits , }\n\t      //      { DecimalDigits , DecimalDigits }\n\n\t      var res, from = pos;\n\t      var quantifier;\n\t      var min, max;\n\n\t      if (match('*')) {\n\t        quantifier = createQuantifier(0, undefined, undefined, undefined, '*');\n\t      }\n\t      else if (match('+')) {\n\t        quantifier = createQuantifier(1, undefined, undefined, undefined, \"+\");\n\t      }\n\t      else if (match('?')) {\n\t        quantifier = createQuantifier(0, 1, undefined, undefined, \"?\");\n\t      }\n\t      else if (res = matchReg(/^\\{([0-9]+)\\}/)) {\n\t        min = parseInt(res[1], 10);\n\t        quantifier = createQuantifier(min, min, res.range[0], res.range[1]);\n\t      }\n\t      else if (res = matchReg(/^\\{([0-9]+),\\}/)) {\n\t        min = parseInt(res[1], 10);\n\t        quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);\n\t      }\n\t      else if (res = matchReg(/^\\{([0-9]+),([0-9]+)\\}/)) {\n\t        min = parseInt(res[1], 10);\n\t        max = parseInt(res[2], 10);\n\t        if (min > max) {\n\t          bail('numbers out of order in {} quantifier', '', from, pos);\n\t        }\n\t        quantifier = createQuantifier(min, max, res.range[0], res.range[1]);\n\t      }\n\n\t      if ((min && !Number.isSafeInteger(min)) || (max && !Number.isSafeInteger(max))) {\n\t        bail(\"iterations outside JS safe integer range in quantifier\", \"\", from, pos);\n\t      }\n\n\t      if (quantifier) {\n\t        if (match('?')) {\n\t          quantifier.greedy = false;\n\t          quantifier.range[1] += 1;\n\t        }\n\t      }\n\n\t      return quantifier;\n\t    }\n\n\t    function parseAtomAndExtendedAtom() {\n\t      // Parsing Atom and ExtendedAtom together due to redundancy.\n\t      // ExtendedAtom is defined in Apendix B of the ECMA-262 standard.\n\t      //\n\t      // SEE: https://www.ecma-international.org/ecma-262/10.0/index.html#prod-annexB-ExtendedPatternCharacter\n\t      //\n\t      // Atom ::\n\t      //      PatternCharacter\n\t      //      .\n\t      //      \\ AtomEscape\n\t      //      CharacterClass\n\t      //      ( GroupSpecifier Disjunction )\n\t      //      ( ? RegularExpressionFlags : Disjunction )\n\t      //      ( ? RegularExpressionFlags - RegularExpressionFlags : Disjunction )\n\t      // ExtendedAtom ::\n\t      //      ExtendedPatternCharacter\n\t      // ExtendedPatternCharacter ::\n\t      //      SourceCharacter but not one of ^$\\.*+?()[|\n\n\t      var res;\n\n\t      // jviereck: allow ']', '}' here as well to be compatible with browser's\n\t      //   implementations: ']'.match(/]/);\n\t      if (res = matchReg(/^[^^$\\\\.*+?()[\\]{}|]/)) {\n\t        //      PatternCharacter\n\t        return createCharacter(res);\n\t      }\n\t      else if (!isUnicodeMode && (res = matchReg(/^(?:]|})/))) {\n\t        //      ExtendedPatternCharacter, first part. See parseTerm.\n\t        return createCharacter(res);\n\t      }\n\t      else if (match('.')) {\n\t        //      .\n\t        return createDot();\n\t      }\n\t      else if (match('\\\\')) {\n\t        //      \\ AtomEscape\n\t        res = parseAtomEscape();\n\t        if (!res) {\n\t          if (!isUnicodeMode && lookahead() == 'c') {\n\t            // B.1.4 ExtendedAtom\n\t            // \\[lookahead = c]\n\t            return createValue('symbol', 92, pos - 1, pos);\n\t          }\n\t          bail('atomEscape');\n\t        }\n\t        return res;\n\t      }\n\t      else if (res = parseCharacterClass()) {\n\t        return res;\n\t      }\n\t      else if (features.lookbehind && (res = parseGroup('(?<=', 'lookbehind', '(?<!', 'negativeLookbehind'))) {\n\t        return res;\n\t      }\n\t      else if (features.namedGroups && match(\"(?<\")) {\n\t        var name = parseIdentifier();\n\t        skip(\">\");\n\t        var group = finishGroup(\"normal\", name.range[0] - 3);\n\t        group.name = name;\n\t        return group;\n\t      }\n\t      else if (features.modifiers && str.indexOf(\"(?\") == pos && str[pos+2] != \":\") {\n\t        return parseModifiersGroup();\n\t      }\n\t      else {\n\t        //      ( Disjunction )\n\t        //      ( ? : Disjunction )\n\t        return parseGroup('(?:', 'ignore', '(', 'normal');\n\t      }\n\t    }\n\n\t    function parseModifiersGroup() {\n\t      function hasDupChar(str) {\n\t        var i = 0;\n\t        while (i < str.length) {\n\t          if (str.indexOf(str[i], i + 1) != -1) {\n\t            return true;\n\t          }\n\t          i++;\n\t        }\n\t        return false;\n\t      }\n\n\t      var from = pos;\n\t      incr(2);\n\n\t      var enablingFlags = matchReg(/^[sim]+/);\n\t      var disablingFlags;\n\t      if(match(\"-\")){\n\t        disablingFlags = matchReg(/^[sim]+/);\n\t        if (!disablingFlags) {\n\t          bail('Invalid flags for modifiers group');\n\t        }\n\t      } else if(!enablingFlags){\n\t        bail('Invalid flags for modifiers group');\n\t      }\n\n\t      enablingFlags = enablingFlags ? enablingFlags[0] : \"\";\n\t      disablingFlags = disablingFlags ? disablingFlags[0] : \"\";\n\n\t      var flags = enablingFlags + disablingFlags;\n\t      if(flags.length > 3 || hasDupChar(flags)) {\n\t        bail('flags cannot be duplicated for modifiers group');\n\t      }\n\n\t      skip(\":\");\n\n\t      var modifiersGroup = finishGroup(\"ignore\", from);\n\n\t      modifiersGroup.modifierFlags = {\n\t          enabling: enablingFlags,\n\t          disabling: disablingFlags\n\t        };\n\n\t      return modifiersGroup;\n\t    }\n\n\t    function parseUnicodeSurrogatePairEscape(firstEscape) {\n\t      if (isUnicodeMode) {\n\t        var first, second;\n\t        if (firstEscape.kind == 'unicodeEscape' &&\n\t          (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF &&\n\t          current('\\\\') && next('u') ) {\n\t          var prevPos = pos;\n\t          pos++;\n\t          var secondEscape = parseClassEscape();\n\t          if (secondEscape.kind == 'unicodeEscape' &&\n\t            (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {\n\t            // Unicode surrogate pair\n\t            firstEscape.range[1] = secondEscape.range[1];\n\t            firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t            firstEscape.type = 'value';\n\t            firstEscape.kind = 'unicodeCodePointEscape';\n\t            addRaw(firstEscape);\n\t          }\n\t          else {\n\t            pos = prevPos;\n\t          }\n\t        }\n\t      }\n\t      return firstEscape;\n\t    }\n\n\t    function parseClassEscape() {\n\t      return parseAtomEscape(true);\n\t    }\n\n\t    function parseAtomEscape(insideCharacterClass) {\n\t      // AtomEscape ::\n\t      //      DecimalEscape\n\t      //      CharacterEscape\n\t      //      CharacterClassEscape\n\t      //      k GroupName\n\n\t      var res, from = pos;\n\n\t      res = parseDecimalEscape(insideCharacterClass) || parseNamedReference();\n\t      if (res) {\n\t        return res;\n\t      }\n\n\t      // For ClassEscape\n\t      if (insideCharacterClass) {\n\t        //     b\n\t        if (match('b')) {\n\t          // 15.10.2.19\n\t          // The production ClassEscape :: b evaluates by returning the\n\t          // CharSet containing the one character <BS> (Unicode value 0008).\n\t          return createEscaped('singleEscape', 0x0008, '\\\\b');\n\t        } else if (match('B')) {\n\t          bail('\\\\B not possible inside of CharacterClass', '', from);\n\t        } else if (!isUnicodeMode && (res = matchReg(/^c([0-9])/))) {\n\t          // B.1.4\n\t          // c ClassControlLetter, ClassControlLetter = DecimalDigit\n\t          return createEscaped('controlLetter', res[1] + 16, res[1], 2);\n\t        } else if (!isUnicodeMode && (res = matchReg(/^c_/))) {\n\t          // B.1.4\n\t          // c ClassControlLetter, ClassControlLetter = _\n\t          return createEscaped('controlLetter', 31, '_', 2);\n\t        }\n\t        //     [+U] -\n\t        if (isUnicodeMode && match('-')) {\n\t          return createEscaped('singleEscape', 0x002d, '\\\\-');\n\t        }\n\t      }\n\n\t      res = parseCharacterClassEscape() || parseCharacterEscape();\n\n\t      return res;\n\t    }\n\n\n\t    function parseDecimalEscape(insideCharacterClass) {\n\t      // DecimalEscape ::\n\t      //      DecimalIntegerLiteral [lookahead ∉ DecimalDigit]\n\n\t      var res, match, from = pos;\n\n\t      if (res = matchReg(/^(?!0)\\d+/)) {\n\t        match = res[0];\n\t        var refIdx = parseInt(res[0], 10);\n\t        if (refIdx <= closedCaptureCounter && !insideCharacterClass) {\n\t          // If the number is smaller than the normal-groups found so\n\t          // far, then it is a reference...\n\t          return createReference(res[0]);\n\t        } else {\n\t          // ... otherwise it needs to be interpreted as a octal (if the\n\t          // number is in an octal format). If it is NOT octal format,\n\t          // then the slash is ignored and the number is matched later\n\t          // as normal characters.\n\n\t          // Recall the negative decision to decide if the input must be parsed\n\t          // a second time with the total normal-groups.\n\t          backrefDenied.push(refIdx);\n\n\t          // \\1 octal escapes are disallowed in unicode mode, but they might\n\t          // be references to groups which haven't been parsed yet.\n\t          // We must parse a second time to determine if \\1 is a reference\n\t          // or an octal scape, and then we can report the error.\n\t          if (firstIteration) {\n\t            shouldReparse = true;\n\t          } else {\n\t            bailOctalEscapeIfUnicode(from, pos);\n\t          }\n\n\t          // Reset the position again, as maybe only parts of the previous\n\t          // matched numbers are actual octal numbers. E.g. in '019' only\n\t          // the '01' should be matched.\n\t          incr(-res[0].length);\n\t          if (res = matchReg(/^[0-7]{1,3}/)) {\n\t            return createEscaped('octal', parseInt(res[0], 8), res[0], 1);\n\t          } else {\n\t            // If we end up here, we have a case like /\\91/. Then the\n\t            // first slash is to be ignored and the 9 & 1 to be treated\n\t            // like ordinary characters. Create a character for the\n\t            // first number only here - other number-characters\n\t            // (if available) will be matched later.\n\t            res = createCharacter(matchReg(/^[89]/));\n\t            return updateRawStart(res, res.range[0] - 1);\n\t          }\n\t        }\n\t      }\n\t      // Only allow octal numbers in the following. All matched numbers start\n\t      // with a zero (if the do not, the previous if-branch is executed).\n\t      // If the number is not octal format and starts with zero (e.g. `091`)\n\t      // then only the zeros `0` is treated here and the `91` are ordinary\n\t      // characters.\n\t      // Example:\n\t      //   /\\091/.exec('\\091')[0].length === 3\n\t      else if (res = matchReg(/^[0-7]{1,3}/)) {\n\t        match = res[0];\n\t        if (match !== '0') {\n\t          bailOctalEscapeIfUnicode(from, pos);\n\t        }\n\t        if (/^0{1,3}$/.test(match)) {\n\t          // If they are all zeros, then only take the first one.\n\t          return createEscaped('null', 0x0000, '0', match.length);\n\t        } else {\n\t          return createEscaped('octal', parseInt(match, 8), match, 1);\n\t        }\n\t      }\n\t      return false;\n\t    }\n\n\t    function bailOctalEscapeIfUnicode(from, pos) {\n\t      if (isUnicodeMode) {\n\t        bail(\"Invalid decimal escape in unicode mode\", null, from, pos);\n\t      }\n\t    }\n\n\t    function parseCharacterClassEscape() {\n\t      // CharacterClassEscape :: one of d D s S w W\n\t      var res;\n\t      if (res = matchReg(/^[dDsSwW]/)) {\n\t        return createCharacterClassEscape(res[0]);\n\t      } else if (features.unicodePropertyEscape && isUnicodeMode && (res = matchReg(/^([pP])\\{([^\\}]+)\\}/))) {\n\t        // https://github.com/jviereck/regjsparser/issues/77\n\t        return addRaw({\n\t          type: 'unicodePropertyEscape',\n\t          negative: res[1] === 'P',\n\t          value: res[2],\n\t          range: [res.range[0] - 1, res.range[1]],\n\t          raw: res[0]\n\t        });\n\t      } else if (features.unicodeSet && hasUnicodeSetFlag && match('q{')) {\n\t        return parseClassStrings();\n\t      }\n\t      return false;\n\t    }\n\n\t    function parseNamedReference() {\n\t      if (features.namedGroups && matchReg(/^k<(?=.*?>)/)) {\n\t        var name = parseIdentifier();\n\t        skip('>');\n\t        return createNamedReference(name);\n\t      }\n\t    }\n\n\t    function parseRegExpUnicodeEscapeSequence() {\n\t      var res;\n\t      if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {\n\t        // UnicodeEscapeSequence\n\t        return parseUnicodeSurrogatePairEscape(\n\t          createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2)\n\t        );\n\t      } else if (isUnicodeMode && (res = matchReg(/^u\\{([0-9a-fA-F]+)\\}/))) {\n\t        // RegExpUnicodeEscapeSequence (ES6 Unicode code point escape)\n\t        return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);\n\t      }\n\t    }\n\n\t    function parseCharacterEscape() {\n\t      // CharacterEscape ::\n\t      //      ControlEscape\n\t      //      c ControlLetter\n\t      //      HexEscapeSequence\n\t      //      UnicodeEscapeSequence\n\t      //      IdentityEscape\n\n\t      var res;\n\t      var from = pos;\n\t      if (res = matchReg(/^[fnrtv]/)) {\n\t        // ControlEscape\n\t        var codePoint = 0;\n\t        switch (res[0]) {\n\t          case 't': codePoint = 0x009; break;\n\t          case 'n': codePoint = 0x00A; break;\n\t          case 'v': codePoint = 0x00B; break;\n\t          case 'f': codePoint = 0x00C; break;\n\t          case 'r': codePoint = 0x00D; break;\n\t        }\n\t        return createEscaped('singleEscape', codePoint, '\\\\' + res[0]);\n\t      } else if (res = matchReg(/^c([a-zA-Z])/)) {\n\t        // c ControlLetter\n\t        return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);\n\t      } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {\n\t        // HexEscapeSequence\n\t        return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);\n\t      } else if (res = parseRegExpUnicodeEscapeSequence()) {\n\t        if (!res || res.codePoint > 0x10FFFF) {\n\t          bail('Invalid escape sequence', null, from, pos);\n\t        }\n\t        return res;\n\t      } else {\n\t        // IdentityEscape\n\t        return parseIdentityEscape();\n\t      }\n\t    }\n\n\t    function parseIdentifierAtom(check) {\n\t      var ch = lookahead();\n\t      var from = pos;\n\t      if (ch === '\\\\') {\n\t        incr();\n\t        var esc = parseRegExpUnicodeEscapeSequence();\n\t        if (!esc || !check(esc.codePoint)) {\n\t          bail('Invalid escape sequence', null, from, pos);\n\t        }\n\t        return fromCodePoint(esc.codePoint);\n\t      }\n\t      var code = ch.charCodeAt(0);\n\t      if (code >= 0xD800 && code <= 0xDBFF) {\n\t        ch += str[pos + 1];\n\t        var second = ch.charCodeAt(1);\n\t        if (second >= 0xDC00 && second <= 0xDFFF) {\n\t          // Unicode surrogate pair\n\t          code = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t        }\n\t      }\n\t      if (!check(code)) return;\n\t      incr();\n\t      if (code > 0xFFFF) incr();\n\t      return ch;\n\t    }\n\n\t    function parseIdentifier() {\n\t      // RegExpIdentifierName ::\n\t      //      RegExpIdentifierStart\n\t      //      RegExpIdentifierName RegExpIdentifierContinue\n\t      //\n\t      // RegExpIdentifierStart ::\n\t      //      UnicodeIDStart\n\t      //      $\n\t      //      _\n\t      //      \\ RegExpUnicodeEscapeSequence\n\t      //\n\t      // RegExpIdentifierContinue ::\n\t      //      UnicodeIDContinue\n\t      //      $\n\t      //      _\n\t      //      \\ RegExpUnicodeEscapeSequence\n\t      //      <ZWNJ>\n\t      //      <ZWJ>\n\n\t      var start = pos;\n\t      var res = parseIdentifierAtom(isIdentifierStart);\n\t      if (!res) {\n\t        bail('Invalid identifier');\n\t      }\n\n\t      var ch;\n\t      while (ch = parseIdentifierAtom(isIdentifierPart)) {\n\t        res += ch;\n\t      }\n\n\t      return addRaw({\n\t        type: 'identifier',\n\t        value: res,\n\t        range: [start, pos]\n\t      });\n\t    }\n\n\t    function isIdentifierStart(ch) {\n\t      // Generated by `tools/generate-identifier-regex.js`.\n\t      var NonAsciiIdentifierStart = /[\\$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7B9\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF1A]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE83\\uDE86-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFF1]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\n\n\t      return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n\t        (ch >= 65 && ch <= 90) ||         // A..Z\n\t        (ch >= 97 && ch <= 122) ||        // a..z\n\t        ((ch >= 0x80) && NonAsciiIdentifierStart.test(fromCodePoint(ch)));\n\t    }\n\n\t    // Taken from the Esprima parser.\n\t    function isIdentifierPart(ch) {\n\t      // Generated by `tools/generate-identifier-regex.js`.\n\t      // eslint-disable-next-line no-misleading-character-class\n\t      var NonAsciiIdentifierPartOnly = /[0-9_\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C04\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u200D\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA8FF-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD801[\\uDCA0-\\uDCA9]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDD30-\\uDD39\\uDF46-\\uDF50]|\\uD804[\\uDC00-\\uDC02\\uDC38-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDC82\\uDCB0-\\uDCBA\\uDCF0-\\uDCF9\\uDD00-\\uDD02\\uDD27-\\uDD34\\uDD36-\\uDD3F\\uDD45\\uDD46\\uDD73\\uDD80-\\uDD82\\uDDB3-\\uDDC0\\uDDC9-\\uDDCC\\uDDD0-\\uDDD9\\uDE2C-\\uDE37\\uDE3E\\uDEDF-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF3B\\uDF3C\\uDF3E-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF62\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC35-\\uDC46\\uDC50-\\uDC59\\uDC5E\\uDCB0-\\uDCC3\\uDCD0-\\uDCD9\\uDDAF-\\uDDB5\\uDDB8-\\uDDC0\\uDDDC\\uDDDD\\uDE30-\\uDE40\\uDE50-\\uDE59\\uDEAB-\\uDEB7\\uDEC0-\\uDEC9\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC2C-\\uDC3A\\uDCE0-\\uDCE9\\uDE01-\\uDE0A\\uDE33-\\uDE39\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE5B\\uDE8A-\\uDE99]|\\uD807[\\uDC2F-\\uDC36\\uDC38-\\uDC3F\\uDC50-\\uDC59\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD50-\\uDD59\\uDD8A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD97\\uDDA0-\\uDDA9\\uDEF3-\\uDEF6]|\\uD81A[\\uDE60-\\uDE69\\uDEF0-\\uDEF4\\uDF30-\\uDF36\\uDF50-\\uDF59]|\\uD81B[\\uDF51-\\uDF7E\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A\\uDD50-\\uDD59]|\\uDB40[\\uDD00-\\uDDEF]/;\n\n\t      return isIdentifierStart(ch) ||\n\t        (ch >= 48 && ch <= 57) ||         // 0..9\n\t        ((ch >= 0x80) && NonAsciiIdentifierPartOnly.test(fromCodePoint(ch)));\n\t    }\n\n\t    function parseIdentityEscape() {\n\t      // IdentityEscape ::\n\t      //      [+U] SyntaxCharacter\n\t      //      [+U] /\n\t      //      [~U] SourceCharacterIdentityEscape[?N]\n\t      // SourceCharacterIdentityEscape[?N] ::\n\t      //      [~N] SourceCharacter but not c\n\t      //      [+N] SourceCharacter but not one of c or k\n\n\n\t      var tmp;\n\t      var l = lookahead();\n\t      if (\n\t        (isUnicodeMode && /[\\^\\$\\.\\*\\+\\?\\(\\)\\\\\\[\\]\\{\\}\\|\\/]/.test(l)) ||\n\t        (!isUnicodeMode && l !== \"c\")\n\t      ) {\n\t        if (l === \"k\" && features.lookbehind) {\n\t          return null;\n\t        }\n\t        tmp = incr();\n\t        return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);\n\t      }\n\n\t      return null;\n\t    }\n\n\t    function parseCharacterClass() {\n\t      // CharacterClass ::\n\t      //      [ [lookahead ∉ {^}] ClassRanges ]\n\t      //      [ ^ ClassRanges ]\n\n\t      var res, from = pos;\n\t      if (res = matchReg(/^\\[\\^/)) {\n\t        res = parseClassRanges();\n\t        skip(']');\n\t        return createCharacterClass(res, true, from, pos);\n\t      } else if (match('[')) {\n\t        res = parseClassRanges();\n\t        skip(']');\n\t        return createCharacterClass(res, false, from, pos);\n\t      }\n\n\t      return null;\n\t    }\n\n\t    function parseClassRanges() {\n\t      // ClassRanges ::\n\t      //      [empty]\n\t      //      [~V] NonemptyClassRanges\n\t      //      [+V] ClassContents\n\n\t      var res;\n\t      if (current(']')) {\n\t        // Empty array means nothing inside of the ClassRange.\n\t        return { kind: 'union', body: [] };\n\t      } else if (hasUnicodeSetFlag) {\n\t        return parseClassContents();\n\t      } else {\n\t        res = parseNonemptyClassRanges();\n\t        if (!res) {\n\t          bail('nonEmptyClassRanges');\n\t        }\n\t        return { kind: 'union', body: res };\n\t      }\n\t    }\n\n\t    function parseHelperClassRanges(atom) {\n\t      var from, to, res, atomTo, dash;\n\t      if (current('-') && !next(']')) {\n\t        // ClassAtom - ClassAtom ClassRanges\n\t        from = atom.range[0];\n\t        dash = createCharacter(match('-'));\n\n\t        atomTo = parseClassAtom();\n\t        if (!atomTo) {\n\t          bail('classAtom');\n\t        }\n\t        to = pos;\n\n\t        // Parse the next class range if exists.\n\t        var classRanges = parseClassRanges();\n\t        if (!classRanges) {\n\t          bail('classRanges');\n\t        }\n\n\t        // Check if both the from and atomTo have codePoints.\n\t        if (!('codePoint' in atom) || !('codePoint' in atomTo)) {\n\t          if (!isUnicodeMode) {\n\t            // If not, don't create a range but treat them as\n\t            // `atom` `-` `atom` instead.\n\t            //\n\t            // SEE: https://tc39.es/ecma262/#sec-regular-expression-patterns-semantics\n\t            //   NonemptyClassRanges::ClassAtom-ClassAtomClassRanges\n\t            //   CharacterRangeOrUnion\n\t            res = [atom, dash, atomTo];\n\t          } else {\n\t            // With unicode flag, both sides must have codePoints if\n\t            // one side has a codePoint.\n\t            //\n\t            // SEE: https://tc39.es/ecma262/#sec-patterns-static-semantics-early-errors\n\t            //   NonemptyClassRanges :: ClassAtom - ClassAtom ClassRanges\n\t            bail('invalid character class');\n\t          }\n\t        } else {\n\t          res = [createClassRange(atom, atomTo, from, to)];\n\t        }\n\n\t        if (classRanges.type === 'empty') {\n\t          return res;\n\t        }\n\t        return res.concat(classRanges.body);\n\t      }\n\n\t      res = parseNonemptyClassRangesNoDash();\n\t      if (!res) {\n\t        bail('nonEmptyClassRangesNoDash');\n\t      }\n\n\t      return [atom].concat(res);\n\t    }\n\n\t    function parseNonemptyClassRanges() {\n\t      // NonemptyClassRanges ::\n\t      //      ClassAtom\n\t      //      ClassAtom NonemptyClassRangesNoDash\n\t      //      ClassAtom - ClassAtom ClassRanges\n\n\t      var atom = parseClassAtom();\n\t      if (!atom) {\n\t        bail('classAtom');\n\t      }\n\n\t      if (current(']')) {\n\t        // ClassAtom\n\t        return [atom];\n\t      }\n\n\t      // ClassAtom NonemptyClassRangesNoDash\n\t      // ClassAtom - ClassAtom ClassRanges\n\t      return parseHelperClassRanges(atom);\n\t    }\n\n\t    function parseNonemptyClassRangesNoDash() {\n\t      // NonemptyClassRangesNoDash ::\n\t      //      ClassAtom\n\t      //      ClassAtomNoDash NonemptyClassRangesNoDash\n\t      //      ClassAtomNoDash - ClassAtom ClassRanges\n\n\t      var res = parseClassAtom();\n\t      if (!res) {\n\t        bail('classAtom');\n\t      }\n\t      if (current(']')) {\n\t        //      ClassAtom\n\t        return res;\n\t      }\n\n\t      // ClassAtomNoDash NonemptyClassRangesNoDash\n\t      // ClassAtomNoDash - ClassAtom ClassRanges\n\t      return parseHelperClassRanges(res);\n\t    }\n\n\t    function parseClassAtom() {\n\t      // ClassAtom ::\n\t      //      -\n\t      //      ClassAtomNoDash\n\t      if (match('-')) {\n\t        return createCharacter('-');\n\t      } else {\n\t        return parseClassAtomNoDash();\n\t      }\n\t    }\n\n\t    function parseClassAtomNoDash() {\n\t      // ClassAtomNoDash ::\n\t      //      SourceCharacter but not one of \\ or ] or -\n\t      //      \\ ClassEscape\n\n\t      var res;\n\t      if (res = matchReg(/^[^\\\\\\]-]/)) {\n\t        return createCharacter(res[0]);\n\t      } else if (match('\\\\')) {\n\t        res = parseClassEscape();\n\t        if (!res) {\n\t          bail('classEscape');\n\t        }\n\n\t        return parseUnicodeSurrogatePairEscape(res);\n\t      }\n\t    }\n\n\t    function parseClassContents() {\n\t      // ClassContents ::\n\t      //      ClassUnion\n\t      //      ClassIntersection\n\t      //      ClassSubtraction\n\t      //\n\t      // ClassUnion ::\n\t      //      ClassRange ClassUnion?\n\t      //      ClassOperand ClassUnion?\n\t      //\n\t      // ClassIntersection ::\n\t      //      ClassOperand && [lookahead ≠ &] ClassOperand\n\t      //      ClassIntersection && [lookahead ≠ &] ClassOperand\n\t      //\n\t      // ClassSubtraction ::\n\t      //      ClassOperand -- ClassOperand\n\t      //      ClassSubtraction -- ClassOperand\n\n\t      var body = [];\n\t      var kind;\n\n\t      var operand = parseClassOperand(/* allowRanges*/ true);\n\t      body.push(operand);\n\n\t      if (operand.type === 'classRange') {\n\t        kind = 'union';\n\t      } else if (current('&')) {\n\t        kind = 'intersection';\n\t      } else if (current('-')) {\n\t        kind = 'subtraction';\n\t      } else {\n\t        kind = 'union';\n\t      }\n\n\t      while (!current(']')) {\n\t        if (kind === 'intersection') {\n\t          skip('&');\n\t          skip('&');\n\t          if (current('&')) {\n\t            bail('&& cannot be followed by &. Wrap it in brackets: &&[&].');\n\t          }\n\t        } else if (kind === 'subtraction') {\n\t          skip('-');\n\t          skip('-');\n\t        }\n\n\t        operand = parseClassOperand(/* allowRanges*/ kind === 'union');\n\t        body.push(operand);\n\t      }\n\n\t      return { kind: kind, body: body };\n\t    }\n\n\t    function parseClassOperand(allowRanges) {\n\t      // ClassOperand ::\n\t      //      ClassCharacter\n\t      //      ClassStrings\n\t      //      NestedClass\n\t      //\n\t      // NestedClass ::\n\t      //      [ [lookahead ≠ ^] ClassRanges[+U,+V] ]\n\t      //      [ ^ ClassRanges[+U,+V] ]\n\t      //      \\ CharacterClassEscape[+U, +V]\n\t      //\n\t      // ClassRange ::\n\t      //      ClassCharacter - ClassCharacter\n\t      //\n\t      // ClassCharacter ::\n\t      //      [lookahead ∉ ClassReservedDouble] SourceCharacter but not ClassSyntaxCharacter\n\t      //      \\ CharacterEscape[+U]\n\t      //      \\ ClassHalfOfDouble\n\t      //      \\ b\n\t      //\n\t      // ClassSyntaxCharacter ::\n\t      //      one of ( ) [ ] { } / - \\ |\n\n\t      var from = pos;\n\t      var start, res;\n\n\t      if (match('\\\\')) {\n\t        // ClassOperand ::\n\t        //      ...\n\t        //      ClassStrings\n\t        //      NestedClass\n\t        //\n\t        // NestedClass ::\n\t        //      ...\n\t        //      \\ CharacterClassEscape[+U, +V]\n\t        if (res = parseClassEscape()) {\n\t          start = res;\n\t        } else if (res = parseClassCharacterEscapedHelper()) {\n\t          return res;\n\t        } else {\n\t          bail('Invalid escape', '\\\\' + lookahead(), from);\n\t        }\n\t      } else if (res = parseClassCharacterUnescapedHelper()) {\n\t        start = res;\n\t      } else if (res = parseCharacterClass()) {\n\t        // ClassOperand ::\n\t        //      ...\n\t        //      NestedClass\n\t        //\n\t        // NestedClass ::\n\t        //      [ [lookahead ≠ ^] ClassRanges[+U,+V] ]\n\t        //      [ ^ ClassRanges[+U,+V] ]\n\t        //      ...\n\t        return res;\n\t      } else {\n\t        bail('Invalid character', lookahead());\n\t      }\n\n\t      if (allowRanges && current('-') && !next('-')) {\n\t        skip('-');\n\n\t        if (res = parseClassCharacter()) {\n\t          // ClassRange ::\n\t          //      ClassCharacter - ClassCharacter\n\t          return createClassRange(start, res, from, pos);\n\t        }\n\n\t        bail('Invalid range end', lookahead());\n\t      }\n\n\t      // ClassOperand ::\n\t      //      ClassCharacter\n\t      //      ...\n\t      return start;\n\t    }\n\n\t    function parseClassCharacter() {\n\t      // ClassCharacter ::\n\t      //      [lookahead ∉ ClassReservedDouble] SourceCharacter but not ClassSyntaxCharacter\n\t      //      \\ CharacterEscape[+U]\n\t      //      \\ ClassHalfOfDouble\n\t      //      \\ b\n\n\t      if (match('\\\\')) {\n\t        var res, from = pos;\n\t        if (res = parseClassCharacterEscapedHelper()) {\n\t          return res;\n\t        } else {\n\t          bail('Invalid escape', '\\\\' + lookahead(), from);\n\t        }\n\t      }\n\n\t      return parseClassCharacterUnescapedHelper();\n\t    }\n\n\t    function parseClassCharacterUnescapedHelper() {\n\t      // ClassCharacter ::\n\t      //      [lookahead ∉ ClassReservedDouble] SourceCharacter but not ClassSyntaxCharacter\n\t      //      ...\n\n\t      var res;\n\t      if (res = matchReg(/^[^()[\\]{}/\\-\\\\|]/)) {\n\t        return createCharacter(res);\n\t      }\n\t    }\n\n\t    function parseClassCharacterEscapedHelper() {\n\t      // ClassCharacter ::\n\t      //      ...\n\t      //      \\ CharacterEscape[+U]\n\t      //      \\ ClassHalfOfDouble\n\t      //      \\ b\n\n\t      var res;\n\t      if (match('b')) {\n\t        return createEscaped('singleEscape', 0x0008, '\\\\b');\n\t      } else if (match('B')) {\n\t        bail('\\\\B not possible inside of ClassContents', '', pos - 2);\n\t      } else if (res = matchReg(/^[&\\-!#%,:;<=>@_`~]/)) {\n\t        return createEscaped('identifier', res[0].codePointAt(0), res[0]);\n\t      } else if (res = parseCharacterEscape()) {\n\t        return res;\n\t      } else {\n\t        return null;\n\t      }\n\t    }\n\n\t    function parseClassStrings() {\n\t      // ClassStrings ::\n\t      //      \\q{ ClassString MoreClassStrings? }\n\n\t      // When calling this function, \\q{ has already been consumed.\n\t      var from = pos - 3;\n\n\t      var res = [];\n\t      do {\n\t        res.push(parseClassString());\n\t      } while (match('|'));\n\n\t      skip('}');\n\n\t      return createClassStrings(res, from, pos);\n\t    }\n\n\t    function parseClassString() {\n\t      // ClassString ::\n\t      //      [empty]\n\t      //      NonEmptyClassString\n\t      //\n\t      // NonEmptyClassString ::\n\t      //      ClassCharacter NonEmptyClassString?\n\n\t      var res = [], from = pos;\n\t      var char;\n\n\t      while (char = parseClassCharacter()) {\n\t        res.push(char);\n\t      }\n\n\t      return createClassString(res, from, pos);\n\t    }\n\n\t    function bail(message, details, from, to) {\n\t      from = from == null ? pos : from;\n\t      to = to == null ? from : to;\n\n\t      var contextStart = Math.max(0, from - 10);\n\t      var contextEnd = Math.min(to + 10, str.length);\n\n\t      // Output a bit of context and a line pointing to where our error is.\n\t      //\n\t      // We are assuming that there are no actual newlines in the content as this is a regular expression.\n\t      var context = '    ' + str.substring(contextStart, contextEnd);\n\t      var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';\n\n\t      throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\\n' + context + '\\n' + pointer);\n\t    }\n\n\t    var backrefDenied = [];\n\t    var closedCaptureCounter = 0;\n\t    var firstIteration = true;\n\t    var shouldReparse = false;\n\t    var hasUnicodeFlag = (flags || \"\").indexOf(\"u\") !== -1;\n\t    var hasUnicodeSetFlag = (flags || \"\").indexOf(\"v\") !== -1;\n\t    var isUnicodeMode = hasUnicodeFlag || hasUnicodeSetFlag;\n\t    var pos = 0;\n\n\t    if (hasUnicodeSetFlag && !features.unicodeSet) {\n\t      throw new Error('The \"v\" flag is only supported when the .unicodeSet option is enabled.');\n\t    }\n\n\t    if (hasUnicodeFlag && hasUnicodeSetFlag) {\n\t      throw new Error('The \"u\" and \"v\" flags are mutually exclusive.');\n\t    }\n\n\t    // Convert the input to a string and treat the empty string special.\n\t    str = String(str);\n\t    if (str === '') {\n\t      str = '(?:)';\n\t    }\n\n\t    var result = parseDisjunction();\n\n\t    if (result.range[1] !== str.length) {\n\t      bail('Could not parse entire input - got stuck', '', result.range[1]);\n\t    }\n\n\t    // The spec requires to interpret the `\\2` in `/\\2()()/` as backreference.\n\t    // As the parser collects the number of capture groups as the string is\n\t    // parsed it is impossible to make these decisions at the point when the\n\t    // `\\2` is handled. In case the local decision turns out to be wrong after\n\t    // the parsing has finished, the input string is parsed a second time with\n\t    // the total number of capture groups set.\n\t    //\n\t    // SEE: https://github.com/jviereck/regjsparser/issues/70\n\t    shouldReparse = shouldReparse || backrefDenied.some(function (ref) {\n\t      return ref <= closedCaptureCounter;\n\t    });\n\t    if (shouldReparse) {\n\t      // Parse the input a second time.\n\t      pos = 0;\n\t      firstIteration = false;\n\t      return parseDisjunction();\n\t    }\n\n\t    return result;\n\t  }\n\n\t  var regjsparser = {\n\t    parse: parse\n\t  };\n\n\t  if (module.exports) {\n\t    module.exports = regjsparser;\n\t  } else {\n\t    window.regjsparser = regjsparser;\n\t  }\n\n\t}());\n} (parser));\n\nfunction parse(pattern, unicode) {\n    var ast = parserExports.parse(pattern, unicode ? 'u' : '', {\n        lookbehind: true,\n        unicodePropertyEscape: true,\n    });\n    return ast;\n}\n\nvar _version = \"3.2.1\";\n\nfunction mergeSets(a, b) {\n    return new Set(__spreadArray(__spreadArray([], __read(a), false), __read(b), false));\n}\nfunction areSetsEqual(a, b) {\n    return a.size === b.size && mergeSets(a, b).size === a.size;\n}\nfunction subtractSets(a, b) {\n    var newSet = new Set(a);\n    b.forEach(function (bEntry) { return newSet.delete(bEntry); });\n    return newSet;\n}\nfunction setsOverlap(a, b) {\n    var total = a.size + b.size;\n    return new Set(__spreadArray(__spreadArray([], __read(a), false), __read(b), false)).size < total;\n}\n\n// here so that can be mocked out for testing\nfunction buildFinalizationRegistry(cleanupCallback) {\n    return new FinalizationRegistry(cleanupCallback);\n}\n\nvar forkSymbol = Symbol('fork');\nvar pendingResultsSymbol = Symbol('pendingResults');\nfunction buildForkableIterator(source) {\n    var onResult = new Set();\n    var registry = buildFinalizationRegistry(function (onResultCallback) {\n        onResult.delete(onResultCallback);\n    });\n    var readSource = function () {\n        var result = source.next();\n        onResult.forEach(function (fn) { return fn(result); });\n    };\n    var makeFork = function (initialPendingResults) {\n        var _a;\n        var iterator = (_a = {},\n            _a[forkSymbol] = function () {\n                return makeFork(this[pendingResultsSymbol]);\n            },\n            _a[pendingResultsSymbol] = initialPendingResults.slice(0),\n            _a.next = function (value) {\n                if (value !== undefined) {\n                    throw new Error('`ForkableIterator` `next()` cannot take a value');\n                }\n                var pendingResults = this[pendingResultsSymbol];\n                if (!pendingResults.length) {\n                    readSource();\n                }\n                return pendingResults.shift();\n            },\n            _a);\n        var ref = new WeakRef(iterator);\n        var callback = function (result) {\n            var maybeIterator = ref.deref();\n            /* istanbul ignore next */\n            maybeIterator === null || maybeIterator === void 0 ? void 0 : maybeIterator[pendingResultsSymbol].push(result);\n        };\n        registry.register(iterator, callback);\n        onResult.add(callback);\n        return iterator;\n    };\n    return makeFork([]);\n}\n/**\n * Create a fork of the provided `ForkableIterator`/`ForkableAsyncIterator` at the current point.\n */\nfunction fork(forkableIterator) {\n    if (!forkableIterator || !forkableIterator[forkSymbol]) {\n        throw new Error('The provided value was not a `ForkableIterator` from `buildForkableIterator()`');\n    }\n    return forkableIterator[forkSymbol]();\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction emptyReader() { return __generator(this, function (_a) {\n    return [2 /*return*/];\n}); }\n/**\n * Returns a reader that can be forked with the `fork` function.\n *\n * The source reader must not be read from directly.\n */\nfunction buildForkableReader(sourceReader) {\n    return buildForkableIterator(sourceReader);\n}\n/**\n * Chains an array of readers together that run consecutively.\n */\nfunction chainReaders(readers) {\n    var readers_1, readers_1_1, reader, next, e_1_1;\n    var e_1, _a;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                _b.trys.push([0, 6, 7, 8]);\n                readers_1 = __values(readers), readers_1_1 = readers_1.next();\n                _b.label = 1;\n            case 1:\n                if (!!readers_1_1.done) return [3 /*break*/, 5];\n                reader = readers_1_1.value;\n                next = void 0;\n                _b.label = 2;\n            case 2:\n                if (!!(next = reader.next()).done) return [3 /*break*/, 4];\n                return [4 /*yield*/, next.value];\n            case 3:\n                _b.sent();\n                return [3 /*break*/, 2];\n            case 4:\n                readers_1_1 = readers_1.next();\n                return [3 /*break*/, 1];\n            case 5: return [3 /*break*/, 8];\n            case 6:\n                e_1_1 = _b.sent();\n                e_1 = { error: e_1_1 };\n                return [3 /*break*/, 8];\n            case 7:\n                try {\n                    if (readers_1_1 && !readers_1_1.done && (_a = readers_1.return)) _a.call(readers_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n                return [7 /*endfinally*/];\n            case 8: return [2 /*return*/];\n        }\n    });\n}\n/**\n * Builds a reader that yields each item in the input array.\n */\nfunction buildArrayReader(input) {\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [5 /*yield**/, __values(input)];\n            case 1:\n                _a.sent();\n                return [2 /*return*/];\n        }\n    });\n}\n\nfunction buildEndReader(offset) {\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, {\n                    bounded: false,\n                    offset: offset,\n                    stack: [],\n                    subType: 'end',\n                    type: characterReaderTypeCharacterEntry,\n                }];\n            case 1:\n                _a.sent();\n                /* istanbul ignore next */\n                throw new Error('Internal error: should not be reading after end');\n        }\n    });\n}\n\n/**\n * Join multiple `CharacterReader`'s together.\n *\n * It has understanding of the `split` type.\n *\n * `getAction` should return\n * - `continue`: This results in `getReader` being called with the next index\n *   and a new `CharacterReader` should be returned\n * - `fork`: This results in the reader splitting, with the split reader being empty,\n *   and then `getReader` is called with the next index and a new `CharacterReader`\n *   should be returned\n * - `stop`: This means the reader will end\n */\nfunction join(getAction, getReader) {\n    var _join = function (_getAction, _getReader, timeSinceEmitSomething) {\n        var i, action, emittedSomething, reader, next, _loop_1;\n        if (timeSinceEmitSomething === void 0) { timeSinceEmitSomething = 0; }\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    i = 0;\n                    _a.label = 1;\n                case 1:\n                    action = _getAction(i, timeSinceEmitSomething);\n                    if (!(action === 'stop')) return [3 /*break*/, 2];\n                    return [2 /*return*/];\n                case 2:\n                    if (!(action === 'fork')) return [3 /*break*/, 4];\n                    return [4 /*yield*/, {\n                            reader: function () { return emptyReader(); },\n                            subType: null,\n                            type: characterReaderTypeSplit,\n                        }];\n                case 3:\n                    _a.sent();\n                    _a.label = 4;\n                case 4:\n                    emittedSomething = false;\n                    reader = _getReader(i);\n                    next = void 0;\n                    _loop_1 = function () {\n                        var value, _b, _i_1, _timeSinceEmittedSomething_1;\n                        return __generator(this, function (_c) {\n                            switch (_c.label) {\n                                case 0:\n                                    value = next.value;\n                                    _b = value.type;\n                                    switch (_b) {\n                                        case characterReaderTypeSplit: return [3 /*break*/, 1];\n                                        case characterReaderTypeCharacterEntry: return [3 /*break*/, 3];\n                                    }\n                                    return [3 /*break*/, 5];\n                                case 1:\n                                    _i_1 = i;\n                                    _timeSinceEmittedSomething_1 = timeSinceEmitSomething;\n                                    return [4 /*yield*/, {\n                                            reader: function () {\n                                                return _join(function (innerIndex, innerTimeSinceEmittedSomething) {\n                                                    return innerIndex === 0\n                                                        ? 'continue'\n                                                        : _getAction(innerIndex + _i_1, innerTimeSinceEmittedSomething);\n                                                }, function (innerIndex) {\n                                                    return innerIndex === 0\n                                                        ? value.reader()\n                                                        : _getReader(innerIndex + _i_1);\n                                                }, _timeSinceEmittedSomething_1);\n                                            },\n                                            subType: value.subType,\n                                            type: characterReaderTypeSplit,\n                                        }];\n                                case 2:\n                                    _c.sent();\n                                    return [3 /*break*/, 5];\n                                case 3:\n                                    if (value.subType !== 'null' &&\n                                        value.subType !== 'start' &&\n                                        value.subType !== 'end') {\n                                        emittedSomething = true;\n                                    }\n                                    return [4 /*yield*/, value];\n                                case 4:\n                                    _c.sent();\n                                    return [3 /*break*/, 5];\n                                case 5: return [2 /*return*/];\n                            }\n                        });\n                    };\n                    _a.label = 5;\n                case 5:\n                    if (!!(next = reader.next()).done) return [3 /*break*/, 7];\n                    return [5 /*yield**/, _loop_1()];\n                case 6:\n                    _a.sent();\n                    return [3 /*break*/, 5];\n                case 7:\n                    timeSinceEmitSomething = emittedSomething\n                        ? 0\n                        : timeSinceEmitSomething + 1;\n                    _a.label = 8;\n                case 8:\n                    i++;\n                    return [3 /*break*/, 1];\n                case 9: return [2 /*return*/];\n            }\n        });\n    };\n    return _join(getAction, getReader);\n}\n/**\n * Joins an array of `CharacterReader`'s together, with  understanding\n * of the `split` type. If a reader splits, when the split reader ends,\n * the next `CharacterReader` in the array will follow.\n */\nfunction joinArray(input) {\n    var length = input.length;\n    return join(function (i) { return (i < length ? 'continue' : 'stop'); }, function (i) { return input[i](); });\n}\n\nfunction buildSequenceCharacterReader(nodes) {\n    return joinArray(nodes.map(function (node) {\n        return function () { return buildCharacterReader(node); };\n    }));\n}\n\n/**\n * Maps each value of a `CharacterReader` from one value to another.\n *\n * It handles the `split` type internally.\n */\nfunction map(reader, handle) {\n    var startThread = function (innerReader) {\n        var next, _loop_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _loop_1 = function () {\n                        var value, _b;\n                        return __generator(this, function (_c) {\n                            switch (_c.label) {\n                                case 0:\n                                    value = next.value;\n                                    _b = value.type;\n                                    switch (_b) {\n                                        case characterReaderTypeSplit: return [3 /*break*/, 1];\n                                        case characterReaderTypeCharacterEntry: return [3 /*break*/, 3];\n                                    }\n                                    return [3 /*break*/, 5];\n                                case 1: return [4 /*yield*/, {\n                                        reader: function () { return startThread(value.reader()); },\n                                        subType: value.subType,\n                                        type: characterReaderTypeSplit,\n                                    }];\n                                case 2:\n                                    _c.sent();\n                                    return [3 /*break*/, 5];\n                                case 3: return [4 /*yield*/, handle(value)];\n                                case 4:\n                                    _c.sent();\n                                    return [3 /*break*/, 5];\n                                case 5: return [2 /*return*/];\n                            }\n                        });\n                    };\n                    _a.label = 1;\n                case 1:\n                    if (!!(next = innerReader.next()).done) return [3 /*break*/, 3];\n                    return [5 /*yield**/, _loop_1()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/];\n            }\n        });\n    };\n    return startThread(reader);\n}\n\nfunction getGroups(stack) {\n    var e_1, _a;\n    var quantifierStack = [];\n    var groups = new Map();\n    try {\n        for (var stack_1 = __values(stack), stack_1_1 = stack_1.next(); !stack_1_1.done; stack_1_1 = stack_1.next()) {\n            var entry = stack_1_1.value;\n            if (entry.type === 'quantifier') {\n                quantifierStack.push(entry);\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            }\n            else if (entry.type === 'group') {\n                groups.set(entry.group, { quantifierStack: __spreadArray([], __read(quantifierStack), false) });\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (stack_1_1 && !stack_1_1.done && (_a = stack_1.return)) _a.call(stack_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return groups;\n}\nfunction getLookaheadStack(stack) {\n    var e_2, _a;\n    var lookaheadStack = [];\n    try {\n        for (var stack_2 = __values(stack), stack_2_1 = stack_2.next(); !stack_2_1.done; stack_2_1 = stack_2.next()) {\n            var entry = stack_2_1.value;\n            if (entry.type === 'group') {\n                var group = entry.group;\n                var behavior = group.behavior;\n                if (behavior === 'lookbehind' ||\n                    behavior === 'negativeLookbehind' ||\n                    behavior === 'negativeLookahead' ||\n                    behavior === 'lookahead') {\n                    lookaheadStack.push(group);\n                }\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (stack_2_1 && !stack_2_1.done && (_a = stack_2.return)) _a.call(stack_2);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return lookaheadStack;\n}\nfunction buildGroupCharacterReader(node) {\n    switch (node.behavior) {\n        case 'lookbehind':\n        case 'negativeLookbehind':\n        case 'lookahead':\n        case 'negativeLookahead': {\n            return buildArrayReader([\n                {\n                    reader: function () {\n                        return joinArray([\n                            function () {\n                                return map(buildSequenceCharacterReader(node.body), function (value) {\n                                    return __assign(__assign({}, value), { stack: __spreadArray([{ group: node, type: 'group' }], __read(value.stack), false) });\n                                });\n                            },\n                            function () { return buildEndReader(node.range[1]); },\n                        ]);\n                    },\n                    subType: node.behavior === 'lookahead' ? 'lookahead' : null,\n                    type: characterReaderTypeSplit,\n                },\n            ]);\n        }\n        case 'ignore':\n        case 'normal': {\n            return map(buildSequenceCharacterReader(node.body), function (value) {\n                return __assign(__assign({}, value), { stack: __spreadArray([{ group: node, type: 'group' }], __read(value.stack), false) });\n            });\n        }\n    }\n}\n\nfunction buildAnchorReader(node) {\n    var _a;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                _a = node.kind;\n                switch (_a) {\n                    case 'end': return [3 /*break*/, 1];\n                    case 'start': return [3 /*break*/, 3];\n                    case 'boundary': return [3 /*break*/, 5];\n                    case 'not-boundary': return [3 /*break*/, 5];\n                }\n                return [3 /*break*/, 6];\n            case 1: return [4 /*yield*/, {\n                    bounded: true,\n                    offset: node.range[0],\n                    stack: [],\n                    subType: 'end',\n                    type: characterReaderTypeCharacterEntry,\n                }];\n            case 2:\n                _b.sent();\n                /* istanbul ignore next */\n                throw new Error('Internal error: should not be reading after end');\n            case 3: return [4 /*yield*/, {\n                    offset: node.range[0],\n                    stack: [],\n                    subType: 'start',\n                    type: characterReaderTypeCharacterEntry,\n                }];\n            case 4:\n                _b.sent();\n                return [3 /*break*/, 6];\n            case 5:\n                {\n                    return [3 /*break*/, 6];\n                }\n            case 6: return [2 /*return*/];\n        }\n    });\n}\n\nfunction characterClassEscapeToRange(value) {\n    if (value === 'd') {\n        // [0-9]\n        return [48, 57];\n    }\n    return null;\n}\nfunction buildCharacterClassEscapeReader(node) {\n    var range;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                range = characterClassEscapeToRange(node.value);\n                return [4 /*yield*/, {\n                        characterGroups: {\n                            characterClassEscapes: new Set(range ? [] : [node.value]),\n                            dot: false,\n                            negated: false,\n                            ranges: range ? [range] : [],\n                            unicodePropertyEscapes: new Set(),\n                        },\n                        node: node,\n                        stack: [],\n                        subType: 'groups',\n                        type: characterReaderTypeCharacterEntry,\n                    }];\n            case 1:\n                _a.sent();\n                return [2 /*return*/];\n        }\n    });\n}\n\nfunction buildCharacterClassCharacterReader(node) {\n    var e_1, _a;\n    var characterGroups = {\n        characterClassEscapes: new Set(),\n        dot: false,\n        negated: !!node.negative,\n        ranges: [],\n        unicodePropertyEscapes: new Set(),\n    };\n    try {\n        for (var _b = __values(node.body), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var expression = _c.value;\n            switch (expression.type) {\n                case 'value': {\n                    characterGroups.ranges.push([\n                        expression.codePoint,\n                        expression.codePoint,\n                    ]);\n                    break;\n                }\n                case 'characterClassRange': {\n                    var min = expression.min, max = expression.max;\n                    characterGroups.ranges.push([min.codePoint, max.codePoint]);\n                    break;\n                }\n                case 'characterClassEscape': {\n                    var range = characterClassEscapeToRange(expression.value);\n                    if (range) {\n                        characterGroups.ranges.push(range);\n                    }\n                    else {\n                        characterGroups.characterClassEscapes.add(expression.value);\n                    }\n                    break;\n                }\n                case 'unicodePropertyEscape': {\n                    characterGroups.unicodePropertyEscapes.add(expression.value);\n                    break;\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return buildArrayReader([\n        {\n            characterGroups: characterGroups,\n            node: node,\n            stack: [],\n            subType: 'groups',\n            type: characterReaderTypeCharacterEntry,\n        },\n    ]);\n}\n\nfunction buildDisjunctionCharacterReader(node) {\n    return chainReaders([\n        buildArrayReader(node.body.slice(0, -1).map(function (part) {\n            return {\n                reader: function () { return buildCharacterReader(part); },\n                subType: null,\n                type: characterReaderTypeSplit,\n            };\n        })),\n        buildCharacterReader(node.body[node.body.length - 1]),\n    ]);\n}\n\nfunction buildDotCharacterReader(node) {\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, {\n                    characterGroups: {\n                        characterClassEscapes: new Set(),\n                        dot: true,\n                        negated: false,\n                        ranges: [],\n                        unicodePropertyEscapes: new Set(),\n                    },\n                    node: node,\n                    stack: [],\n                    subType: 'groups',\n                    type: characterReaderTypeCharacterEntry,\n                }];\n            case 1:\n                _a.sent();\n                return [2 /*return*/];\n        }\n    });\n}\n\nfunction buildReferenceCharacterReader(node) {\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, {\n                    node: node,\n                    referenceIndex: node.matchIndex,\n                    stack: [],\n                    subType: 'reference',\n                    type: characterReaderTypeCharacterEntry,\n                }];\n            case 1:\n                _a.sent();\n                return [2 /*return*/];\n        }\n    });\n}\n\nfunction buildUnicodePropertyEscapeCharacterReader(node) {\n    return buildArrayReader([\n        {\n            characterGroups: {\n                characterClassEscapes: new Set(),\n                dot: false,\n                negated: node.negative,\n                ranges: [],\n                unicodePropertyEscapes: new Set([node.value]),\n            },\n            node: node,\n            stack: [],\n            subType: 'groups',\n            type: characterReaderTypeCharacterEntry,\n        },\n    ]);\n}\n\nfunction buildValueCharacterReader(node) {\n    return buildArrayReader([\n        {\n            characterGroups: {\n                characterClassEscapes: new Set(),\n                dot: false,\n                negated: false,\n                ranges: [[node.codePoint, node.codePoint]],\n                unicodePropertyEscapes: new Set(),\n            },\n            node: node,\n            stack: [],\n            subType: 'groups',\n            type: characterReaderTypeCharacterEntry,\n        },\n    ]);\n}\n\nvar characterReaderTypeCharacterEntry = Symbol('characterReaderTypeCharacterEntry');\nvar characterReaderTypeSplit = Symbol('characterReaderTypeSplit');\nfunction buildCharacterReader(node) {\n    switch (node.type) {\n        case 'anchor':\n            return buildAnchorReader(node);\n        case 'characterClass':\n            return buildCharacterClassCharacterReader(node);\n        case 'characterClassEscape':\n            return buildCharacterClassEscapeReader(node);\n        case 'unicodePropertyEscape':\n            return buildUnicodePropertyEscapeCharacterReader(node);\n        case 'reference':\n            return buildReferenceCharacterReader(node);\n        case 'value':\n            return buildValueCharacterReader(node);\n        case 'dot':\n            return buildDotCharacterReader(node);\n        case 'alternative':\n            return buildSequenceCharacterReader(node.body);\n        case 'disjunction':\n            return buildDisjunctionCharacterReader(node);\n        case 'group':\n            return buildGroupCharacterReader(node);\n        case 'quantifier':\n            return buildQuantifierCharacterReader(node);\n    }\n}\n\nfunction buildNullCharacterReader(offset) {\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, {\n                    offset: offset,\n                    stack: [],\n                    subType: 'null',\n                    type: characterReaderTypeCharacterEntry,\n                }];\n            case 1:\n                _a.sent();\n                return [2 /*return*/];\n        }\n    });\n}\n\nfunction getQuantifierStack(stack) {\n    var e_1, _a;\n    var quantifierStack = [];\n    try {\n        for (var stack_1 = __values(stack), stack_1_1 = stack_1.next(); !stack_1_1.done; stack_1_1 = stack_1.next()) {\n            var entry = stack_1_1.value;\n            if (entry.type === 'quantifier') {\n                quantifierStack.push(entry);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (stack_1_1 && !stack_1_1.done && (_a = stack_1.return)) _a.call(stack_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return quantifierStack;\n}\nfunction buildQuantifiersInInfinitePortion(stack) {\n    return new Set(stack\n        .filter(function (_a) {\n        var inInfinitePortion = _a.inInfinitePortion;\n        return inInfinitePortion;\n    })\n        .map(function (_a) {\n        var quantifier = _a.quantifier;\n        return quantifier;\n    }));\n}\nfunction buildQuantifierIterations(stack) {\n    var res = new Map();\n    stack.forEach(function (_a) {\n        var iteration = _a.iteration, quantifier = _a.quantifier;\n        return res.set(quantifier, iteration);\n    });\n    return res;\n}\n// \"<node offset>:<iteration number or * if in infinite portion>,...\"\nfunction buildQuantifierTrail(stack, asteriskInfinite) {\n    return stack\n        .map(function (_a) {\n        var quantifier = _a.quantifier, inInfinitePortion = _a.inInfinitePortion, iteration = _a.iteration;\n        return \"\".concat(quantifier.range[0], \":\").concat(asteriskInfinite && inInfinitePortion ? '*' : \"\".concat(iteration));\n    })\n        .join(',');\n}\nfunction buildQuantifierCharacterReader(node) {\n    var min = node.min, _a = node.max, max = _a === void 0 ? Infinity : _a;\n    return joinArray([\n        // always emit the null first so that we always emit something in cases where the loop is empty\n        function () { return buildNullCharacterReader(node.body[0].range[0]); },\n        function () {\n            return join(function (i, timeSinceEmit) {\n                // prevent infinite loop on something like `()*`\n                // > 1 so that the capturing groups are cleared with something like `(?:(a)|)*`\n                if (timeSinceEmit > 1)\n                    return 'stop';\n                if (i >= max)\n                    return 'stop';\n                if (i >= min)\n                    return 'fork';\n                return 'continue';\n            }, function (i) {\n                return map(joinArray(__spreadArray(__spreadArray([], __read((i > 0\n                    ? [\n                        function () {\n                            return buildNullCharacterReader(node.body[0].range[0]);\n                        },\n                    ]\n                    : [])), false), [\n                    function () { return buildCharacterReader(node.body[0]); },\n                ], false)), function (value) {\n                    var inInfinitePortion = i >= min && i >= 1 && max === Infinity;\n                    return __assign(__assign({}, value), { stack: __spreadArray([\n                            {\n                                inInfinitePortion: inInfinitePortion,\n                                iteration: i,\n                                quantifier: node,\n                                type: 'quantifier',\n                            }\n                        ], __read(value.stack), false) });\n                });\n            });\n        },\n    ]);\n}\n\nfunction subtractRanges(source, toSubtract) {\n    var res = [];\n    if (source[0] < toSubtract[0]) {\n        res.push([source[0], Math.min(toSubtract[0] - 1, source[1])]);\n    }\n    if (source[1] > toSubtract[1]) {\n        res.push([Math.max(toSubtract[1] + 1, source[0]), source[1]]);\n    }\n    return res;\n}\nfunction intersectRanges(a, b) {\n    var startShared = Math.max(a[0], b[0]);\n    var endShared = Math.min(a[1], b[1]);\n    if (startShared > endShared) {\n        return null;\n    }\n    var shared = [startShared, endShared];\n    return {\n        a: subtractRanges(a, shared),\n        b: subtractRanges(b, shared),\n        shared: shared,\n    };\n}\n\n/**\n * Returns `true` if the provided `CharacterGroups` definitely matches no characters.\n */\nfunction isEmptyCharacterGroups(group) {\n    return (!group.negated &&\n        !group.ranges.length &&\n        !group.dot &&\n        !group.characterClassEscapes.size &&\n        !group.unicodePropertyEscapes.size);\n}\nfunction intersectTwoCharacterGroups(a, b) {\n    var newRanges;\n    var newChracterClassEscapes;\n    var newUnicodePropertyEscapes;\n    var newNegated;\n    var newDot;\n    if (a.dot || b.dot) {\n        if (a.dot && b.dot) {\n            newDot = true;\n            newNegated = false;\n            newRanges = [];\n            newChracterClassEscapes = new Set();\n            newUnicodePropertyEscapes = new Set();\n        }\n        else if (a.dot) {\n            newDot = false;\n            newNegated = b.negated;\n            newRanges = b.ranges;\n            newChracterClassEscapes = b.characterClassEscapes;\n            newUnicodePropertyEscapes = b.unicodePropertyEscapes;\n        }\n        else {\n            newDot = false;\n            newNegated = a.negated;\n            newRanges = a.ranges;\n            newChracterClassEscapes = a.characterClassEscapes;\n            newUnicodePropertyEscapes = a.unicodePropertyEscapes;\n        }\n    }\n    else {\n        newDot = false;\n        if (!a.negated) {\n            if (!b.negated) {\n                newNegated = false;\n                newRanges = [];\n                a.ranges.forEach(function (aRange) {\n                    b.ranges.forEach(function (bRange) {\n                        var intersection = intersectRanges(aRange, bRange);\n                        if (intersection) {\n                            newRanges.push(intersection.shared);\n                        }\n                    });\n                });\n                newChracterClassEscapes = mergeSets(a.characterClassEscapes, b.characterClassEscapes);\n                newUnicodePropertyEscapes = mergeSets(a.unicodePropertyEscapes, b.unicodePropertyEscapes);\n            }\n            else {\n                newNegated = false;\n                newRanges = __spreadArray([], __read(a.ranges), false);\n                b.ranges.forEach(function (bRange) {\n                    var narrowed = [];\n                    newRanges.forEach(function (aRange) {\n                        var intersection = intersectRanges(aRange, bRange);\n                        if (!intersection) {\n                            narrowed.push(aRange);\n                        }\n                        else {\n                            narrowed.push.apply(narrowed, __spreadArray([], __read(intersection.a), false));\n                        }\n                    });\n                    newRanges = narrowed;\n                });\n                // assume all escapes in a are not cancelled in b\n                // except exact matches\n                newChracterClassEscapes = subtractSets(a.characterClassEscapes, b.characterClassEscapes);\n                newUnicodePropertyEscapes = subtractSets(a.unicodePropertyEscapes, b.unicodePropertyEscapes);\n            }\n        }\n        else {\n            if (!b.negated) {\n                newNegated = false;\n                newRanges = __spreadArray([], __read(b.ranges), false);\n                a.ranges.forEach(function (aRange) {\n                    var narrowed = [];\n                    newRanges.forEach(function (bRange) {\n                        var intersection = intersectRanges(aRange, bRange);\n                        if (!intersection) {\n                            narrowed.push(bRange);\n                        }\n                        else {\n                            narrowed.push.apply(narrowed, __spreadArray([], __read(intersection.b), false));\n                        }\n                    });\n                    newRanges = narrowed;\n                });\n                // assume all escapes in b were covered in the not-a\n                // except exact matches\n                newChracterClassEscapes = subtractSets(b.characterClassEscapes, a.characterClassEscapes);\n                newUnicodePropertyEscapes = subtractSets(b.unicodePropertyEscapes, a.unicodePropertyEscapes);\n            }\n            else {\n                newNegated = true;\n                newRanges = [];\n                a.ranges.forEach(function (aRange) {\n                    b.ranges.forEach(function (bRange) {\n                        newRanges.push(aRange);\n                        newRanges.push(bRange);\n                    });\n                });\n                newChracterClassEscapes = mergeSets(a.characterClassEscapes, b.characterClassEscapes);\n                newUnicodePropertyEscapes = mergeSets(a.unicodePropertyEscapes, b.unicodePropertyEscapes);\n            }\n        }\n    }\n    return {\n        characterClassEscapes: newChracterClassEscapes,\n        dot: newDot,\n        negated: newNegated,\n        ranges: newRanges,\n        unicodePropertyEscapes: newUnicodePropertyEscapes,\n    };\n}\nfunction intersectCharacterGroups(groups) {\n    var res = groups[0];\n    for (var i = 1; i < groups.length; i++) {\n        res = intersectTwoCharacterGroups(res, groups[i]);\n    }\n    return res;\n}\n\nvar characterReaderLevel1TypeSplit = Symbol('characterReaderLevel2TypeSplit');\nvar characterReaderLevel1TypeEntry = Symbol('characterReaderLevel1TypeEntry');\n/**\n * Returns a `CharacterReaderLevel1` which builds on top of\n * `CharacterReaderLevel0` adds a `preceedingZeroWidthEntries` property\n * and makes every result map to a character.\n */\nfunction buildCharacterReaderLevel1(node) {\n    var startThread = function (reader, preceedingZeroWidthEntries) {\n        var next, _loop_1, state_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _loop_1 = function () {\n                        var _b, _c, value_1, _preceedingZeroWidthEntries_1;\n                        return __generator(this, function (_d) {\n                            switch (_d.label) {\n                                case 0:\n                                    _b = next.value.type;\n                                    switch (_b) {\n                                        case characterReaderTypeCharacterEntry: return [3 /*break*/, 1];\n                                        case characterReaderTypeSplit: return [3 /*break*/, 10];\n                                    }\n                                    return [3 /*break*/, 12];\n                                case 1:\n                                    _c = next.value.subType;\n                                    switch (_c) {\n                                        case 'groups': return [3 /*break*/, 2];\n                                        case 'reference': return [3 /*break*/, 4];\n                                        case 'end': return [3 /*break*/, 6];\n                                        case 'null': return [3 /*break*/, 7];\n                                        case 'start': return [3 /*break*/, 8];\n                                    }\n                                    return [3 /*break*/, 9];\n                                case 2: return [4 /*yield*/, {\n                                        characterGroups: next.value.characterGroups,\n                                        node: next.value.node,\n                                        preceedingZeroWidthEntries: preceedingZeroWidthEntries,\n                                        stack: next.value.stack,\n                                        subType: 'groups',\n                                        type: characterReaderLevel1TypeEntry,\n                                    }];\n                                case 3:\n                                    _d.sent();\n                                    preceedingZeroWidthEntries = [];\n                                    return [3 /*break*/, 9];\n                                case 4: return [4 /*yield*/, {\n                                        node: next.value.node,\n                                        preceedingZeroWidthEntries: preceedingZeroWidthEntries,\n                                        referenceIndex: next.value.referenceIndex,\n                                        stack: next.value.stack,\n                                        subType: next.value.subType,\n                                        type: characterReaderLevel1TypeEntry,\n                                    }];\n                                case 5:\n                                    _d.sent();\n                                    preceedingZeroWidthEntries = [];\n                                    return [3 /*break*/, 9];\n                                case 6:\n                                    {\n                                        return [2 /*return*/, { value: {\n                                                    bounded: next.value.bounded,\n                                                    preceedingZeroWidthEntries: preceedingZeroWidthEntries,\n                                                } }];\n                                    }\n                                case 7:\n                                    {\n                                        preceedingZeroWidthEntries = __spreadArray(__spreadArray([], __read(preceedingZeroWidthEntries), false), [\n                                            { offset: next.value.offset, type: 'null' },\n                                        ], false);\n                                        return [3 /*break*/, 9];\n                                    }\n                                case 8:\n                                    {\n                                        preceedingZeroWidthEntries = __spreadArray(__spreadArray([], __read(preceedingZeroWidthEntries), false), [\n                                            { offset: next.value.offset, type: 'start' },\n                                        ], false);\n                                        return [3 /*break*/, 9];\n                                    }\n                                case 9: return [3 /*break*/, 12];\n                                case 10:\n                                    value_1 = next.value;\n                                    _preceedingZeroWidthEntries_1 = preceedingZeroWidthEntries;\n                                    return [4 /*yield*/, {\n                                            reader: function () {\n                                                return startThread(value_1.reader(), _preceedingZeroWidthEntries_1);\n                                            },\n                                            subType: value_1.subType,\n                                            type: characterReaderLevel1TypeSplit,\n                                        }];\n                                case 11:\n                                    _d.sent();\n                                    return [3 /*break*/, 12];\n                                case 12: return [2 /*return*/];\n                            }\n                        });\n                    };\n                    _a.label = 1;\n                case 1:\n                    if (!!(next = reader.next()).done) return [3 /*break*/, 3];\n                    return [5 /*yield**/, _loop_1()];\n                case 2:\n                    state_1 = _a.sent();\n                    if (typeof state_1 === \"object\")\n                        return [2 /*return*/, state_1.value];\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/, { bounded: false, preceedingZeroWidthEntries: preceedingZeroWidthEntries }];\n            }\n        });\n    };\n    return startThread(buildCharacterReader(node), []);\n}\n\nfunction last(input) {\n    var length = input.length;\n    return length ? input[length - 1] : null;\n}\nfunction areArraysEqual(a, b) {\n    if (a.length !== b.length)\n        return false;\n    return a.every(function (value, i) { return value === b[i]; });\n}\nfunction dropCommon(a, b) {\n    var commonLevels;\n    for (commonLevels = 0; commonLevels < a.length &&\n        commonLevels < b.length &&\n        a[commonLevels] === b[commonLevels]; commonLevels++)\n        ;\n    return {\n        a: a.slice(commonLevels),\n        b: b.slice(commonLevels),\n    };\n}\n\nfunction areMapsEqual(a, b) {\n    var e_1, _a;\n    if (a.size !== b.size)\n        return false;\n    try {\n        for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {\n            var _b = __read(a_1_1.value, 2), key = _b[0], value = _b[1];\n            if (b.has(key) && b.get(key) !== value) {\n                return false;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return true;\n}\nfunction mustGet(map, key) {\n    if (!map.has(key)) {\n        throw new Error('Internal error: map missing key');\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return map.get(key);\n}\n\nvar characterReaderLevel2TypeSplit = Symbol('characterReaderLevel2TypeSplit');\nvar characterReaderLevel2TypeEntry = Symbol('characterReaderLevel2TypeEntry');\nfunction internalStackToLevel1Stack(internalStack) {\n    var e_1, _a;\n    var stack = [];\n    try {\n        for (var internalStack_1 = __values(internalStack), internalStack_1_1 = internalStack_1.next(); !internalStack_1_1.done; internalStack_1_1 = internalStack_1.next()) {\n            var entry = internalStack_1_1.value;\n            if (entry.type !== 'reference')\n                stack.push(entry);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (internalStack_1_1 && !internalStack_1_1.done && (_a = internalStack_1.return)) _a.call(internalStack_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return stack;\n}\n// `InternalReader` is the same as `CharacteReaderLevel1`, except that the `stack` is `InternalStack`\n// which can represent references\nvar internalReaderTypeSplit = Symbol('internalReaderTypeSplit');\nvar internalReaderTypeEntry = Symbol('internalReaderTypeEntry');\nfunction characterReaderLevel1ToInternalReader(characterReaderLevel1) {\n    var next, _loop_1;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                _loop_1 = function () {\n                    var value, _b;\n                    return __generator(this, function (_c) {\n                        switch (_c.label) {\n                            case 0:\n                                value = next.value;\n                                _b = value.type;\n                                switch (_b) {\n                                    case characterReaderLevel1TypeSplit: return [3 /*break*/, 1];\n                                    case characterReaderLevel1TypeEntry: return [3 /*break*/, 3];\n                                }\n                                return [3 /*break*/, 5];\n                            case 1: return [4 /*yield*/, {\n                                    reader: function () {\n                                        return characterReaderLevel1ToInternalReader(value.reader());\n                                    },\n                                    subType: value.subType,\n                                    type: internalReaderTypeSplit,\n                                }];\n                            case 2:\n                                _c.sent();\n                                return [3 /*break*/, 5];\n                            case 3: return [4 /*yield*/, __assign(__assign({}, value), { type: internalReaderTypeEntry })];\n                            case 4:\n                                _c.sent();\n                                return [3 /*break*/, 5];\n                            case 5: return [2 /*return*/];\n                        }\n                    });\n                };\n                _a.label = 1;\n            case 1:\n                if (!!(next = characterReaderLevel1.next()).done) return [3 /*break*/, 3];\n                return [5 /*yield**/, _loop_1()];\n            case 2:\n                _a.sent();\n                return [3 /*break*/, 1];\n            case 3: return [2 /*return*/, next.value];\n        }\n    });\n}\nfunction haveHadCompleteIteration(before, now) {\n    var e_2, _a;\n    try {\n        for (var now_1 = __values(now), now_1_1 = now_1.next(); !now_1_1.done; now_1_1 = now_1.next()) {\n            var _b = __read(now_1_1.value, 2), quantifier = _b[0], iterationsNow = _b[1];\n            var iterationsBefore = before.get(quantifier) || 0;\n            if (iterationsNow - iterationsBefore > 1) {\n                return true;\n            }\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (now_1_1 && !now_1_1.done && (_a = now_1.return)) _a.call(now_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return false;\n}\nfunction getGroupContentsReader(_a) {\n    var group, groupContents, groupLookaheadStack, _b, _c, groupEntry, e_3_1;\n    var e_3, _d;\n    var groupContentsStore = _a.groupContentsStore, groups = _a.groups, groupsWithInfiniteSize = _a.groupsWithInfiniteSize, nodeExtra = _a.nodeExtra, value = _a.value;\n    return __generator(this, function (_e) {\n        switch (_e.label) {\n            case 0:\n                group = mustGet(nodeExtra.indexToCapturingGroup, value.referenceIndex);\n                groupContents = groupContentsStore.get(value.referenceIndex) || {\n                    contents: [],\n                    group: group,\n                };\n                groupLookaheadStack = dropCommon(mustGet(nodeExtra.nodeToLookaheadStack, groupContents.group), mustGet(nodeExtra.nodeToLookaheadStack, value.node)).a;\n                if (groupLookaheadStack.length) {\n                    if (groupLookaheadStack.some(function (_a) {\n                        var behavior = _a.behavior;\n                        return behavior === 'negativeLookahead' || behavior === 'negativeLookbehind';\n                    })) {\n                        return [2 /*return*/, { bounded: false, preceedingZeroWidthEntries: [] }];\n                    }\n                    throw new Error(\"Unsupported reference (\".concat(value.referenceIndex, \" at position \").concat(value.node.range[0], \"). Pattern needs downgrading. See the `downgradePattern` option.\"));\n                }\n                if (groups.has(groupContents.group) /* reference is inside group being referenced */) {\n                    return [2 /*return*/, { bounded: false, preceedingZeroWidthEntries: [] }];\n                }\n                if (groupsWithInfiniteSize.has(value.referenceIndex)) {\n                    throw new Error(\"Unsupported reference to group \".concat(value.referenceIndex, \" as group is not a finite size. Pattern needs downgrading. See the `downgradePattern` option.\"));\n                }\n                _e.label = 1;\n            case 1:\n                _e.trys.push([1, 6, 7, 8]);\n                _b = __values(groupContents.contents), _c = _b.next();\n                _e.label = 2;\n            case 2:\n                if (!!_c.done) return [3 /*break*/, 5];\n                groupEntry = _c.value;\n                return [4 /*yield*/, {\n                        characterGroups: groupEntry.characterGroups,\n                        node: groupEntry.node,\n                        preceedingZeroWidthEntries: groupEntry.preceedingZeroWidthEntries,\n                        stack: __spreadArray(__spreadArray([\n                            {\n                                reference: value.node,\n                                type: \"reference\",\n                            }\n                        ], __read(groupEntry.stack.filter(function (_a) {\n                            var type = _a.type;\n                            return type === \"reference\";\n                        })), false), __read(value.stack), false),\n                        subType: 'groups',\n                        type: internalReaderTypeEntry,\n                    }];\n            case 3:\n                _e.sent();\n                _e.label = 4;\n            case 4:\n                _c = _b.next();\n                return [3 /*break*/, 2];\n            case 5: return [3 /*break*/, 8];\n            case 6:\n                e_3_1 = _e.sent();\n                e_3 = { error: e_3_1 };\n                return [3 /*break*/, 8];\n            case 7:\n                try {\n                    if (_c && !_c.done && (_d = _b.return)) _d.call(_b);\n                }\n                finally { if (e_3) throw e_3.error; }\n                return [7 /*endfinally*/];\n            case 8: return [2 /*return*/, { bounded: false, preceedingZeroWidthEntries: [] }];\n        }\n    });\n}\n/**\n * Returns a `CharacterReaderLevel2` which builds on top of\n * `CharacterReaderLevel1` but replaces references with their\n * contents and includes the backreference stack.\n */\nfunction buildCharacterReaderLevel2(node, nodeExtra) {\n    var startThread = function (state) {\n        var _loop_2, state_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _loop_2 = function () {\n                        var preceedingZeroWidthEntries, groupsWithInfiniteSize, groupContentsStore, quantifierIterationsAtLastGroup, characterReader, referenceCharacterReaderWithReference, activeCharacterReader, result, value, _b, _groupContentsStore_1, _quantifierIterationsAtLastGroup_1, _groupsWithInfiniteSize_1, _preceedingZeroWidthEntries_1, quantifierStack, quantifierIterations, lookaheadStack, groups, _c, groupContentsReader, newGroupContentsStore, groupContentsStore_1, groupContentsStore_1_1, _d, index, group, offsets, offsets_1, offsets_1_1, offset, groupInfiniteSize, _loop_3, _e, _f, stackEntry;\n                        var e_4, _g, e_5, _h, e_6, _j;\n                        return __generator(this, function (_k) {\n                            switch (_k.label) {\n                                case 0:\n                                    preceedingZeroWidthEntries = state.preceedingZeroWidthEntries, groupsWithInfiniteSize = state.groupsWithInfiniteSize, groupContentsStore = state.groupContentsStore, quantifierIterationsAtLastGroup = state.quantifierIterationsAtLastGroup;\n                                    characterReader = state.characterReader, referenceCharacterReaderWithReference = state.referenceCharacterReaderWithReference;\n                                    activeCharacterReader = (referenceCharacterReaderWithReference === null || referenceCharacterReaderWithReference === void 0 ? void 0 : referenceCharacterReaderWithReference.reader) || characterReader;\n                                    result = activeCharacterReader.next();\n                                    if (result.done) {\n                                        if (referenceCharacterReaderWithReference) {\n                                            /* istanbul ignore next */\n                                            if (result.value.bounded) {\n                                                // for this to happen it means we must be inside a group (from a reference)\n                                                // that contains `$`\n                                                // but we should have stopped reading when the `$` was hit the first time\n                                                // e.g `($)\\1` should not reach the `\\1`\n                                                throw new Error('Internal error: end of reference reader cannot be bounded');\n                                            }\n                                            state = {\n                                                characterReader: characterReader,\n                                                groupContentsStore: groupContentsStore,\n                                                groupsWithInfiniteSize: groupsWithInfiniteSize,\n                                                preceedingZeroWidthEntries: __spreadArray(__spreadArray([], __read(preceedingZeroWidthEntries), false), __read(result.value.preceedingZeroWidthEntries), false),\n                                                quantifierIterationsAtLastGroup: quantifierIterationsAtLastGroup,\n                                                referenceCharacterReaderWithReference: null,\n                                            };\n                                            return [2 /*return*/, \"continue-outer\"];\n                                        }\n                                        return [2 /*return*/, { value: {\n                                                    bounded: result.value.bounded,\n                                                    preceedingZeroWidthEntries: __spreadArray(__spreadArray([], __read(preceedingZeroWidthEntries), false), __read(result.value.preceedingZeroWidthEntries), false),\n                                                    type: 'end',\n                                                } }];\n                                    }\n                                    value = result.value;\n                                    _b = value.type;\n                                    switch (_b) {\n                                        case internalReaderTypeSplit: return [3 /*break*/, 1];\n                                        case internalReaderTypeEntry: return [3 /*break*/, 3];\n                                    }\n                                    return [3 /*break*/, 7];\n                                case 1:\n                                    /* istanbul ignore next */\n                                    if (referenceCharacterReaderWithReference) {\n                                        throw new Error('Internal error: should not be seeing a split from a reference reader');\n                                    }\n                                    _groupContentsStore_1 = groupContentsStore;\n                                    _quantifierIterationsAtLastGroup_1 = quantifierIterationsAtLastGroup;\n                                    _groupsWithInfiniteSize_1 = groupsWithInfiniteSize;\n                                    _preceedingZeroWidthEntries_1 = preceedingZeroWidthEntries;\n                                    return [4 /*yield*/, {\n                                            reader: function () {\n                                                return startThread({\n                                                    characterReader: buildForkableReader(value.reader()),\n                                                    groupContentsStore: _groupContentsStore_1,\n                                                    groupsWithInfiniteSize: _groupsWithInfiniteSize_1,\n                                                    preceedingZeroWidthEntries: _preceedingZeroWidthEntries_1,\n                                                    quantifierIterationsAtLastGroup: _quantifierIterationsAtLastGroup_1,\n                                                    referenceCharacterReaderWithReference: referenceCharacterReaderWithReference,\n                                                });\n                                            },\n                                            subType: value.subType,\n                                            type: characterReaderLevel2TypeSplit,\n                                        }];\n                                case 2:\n                                    _k.sent();\n                                    return [3 /*break*/, 7];\n                                case 3:\n                                    preceedingZeroWidthEntries = __spreadArray(__spreadArray([], __read(preceedingZeroWidthEntries), false), __read(value.preceedingZeroWidthEntries), false);\n                                    quantifierStack = getQuantifierStack(internalStackToLevel1Stack(value.stack));\n                                    quantifierIterations = buildQuantifierIterations(quantifierStack);\n                                    lookaheadStack = getLookaheadStack(internalStackToLevel1Stack(value.stack));\n                                    groups = getGroups(internalStackToLevel1Stack(value.stack));\n                                    _c = value.subType;\n                                    switch (_c) {\n                                        case 'reference': return [3 /*break*/, 4];\n                                        case 'groups': return [3 /*break*/, 5];\n                                    }\n                                    return [3 /*break*/, 7];\n                                case 4:\n                                    {\n                                        /* istanbul ignore next */\n                                        if (referenceCharacterReaderWithReference) {\n                                            throw new Error('Internal error: should not be seeing a reference from a reference reader');\n                                        }\n                                        if (haveHadCompleteIteration(quantifierIterationsAtLastGroup, quantifierIterations)) {\n                                            return [2 /*return*/, { value: {\n                                                        type: 'abort',\n                                                    } }];\n                                        }\n                                        groupContentsReader = buildForkableReader(getGroupContentsReader({\n                                            groupContentsStore: groupContentsStore,\n                                            groups: groups,\n                                            groupsWithInfiniteSize: groupsWithInfiniteSize,\n                                            nodeExtra: nodeExtra,\n                                            value: value,\n                                        }));\n                                        state = {\n                                            characterReader: characterReader,\n                                            groupContentsStore: groupContentsStore,\n                                            groupsWithInfiniteSize: groupsWithInfiniteSize,\n                                            preceedingZeroWidthEntries: preceedingZeroWidthEntries,\n                                            quantifierIterationsAtLastGroup: quantifierIterationsAtLastGroup,\n                                            referenceCharacterReaderWithReference: {\n                                                reader: groupContentsReader,\n                                                reference: value.node,\n                                            },\n                                        };\n                                        return [3 /*break*/, 7];\n                                    }\n                                case 5:\n                                    newGroupContentsStore = new Map(groupContentsStore);\n                                    if (!referenceCharacterReaderWithReference) {\n                                        try {\n                                            // Clear groups that are now ahead\n                                            // This can happen when a quantifier containing a group restarts\n                                            for (groupContentsStore_1 = (e_4 = void 0, __values(groupContentsStore)), groupContentsStore_1_1 = groupContentsStore_1.next(); !groupContentsStore_1_1.done; groupContentsStore_1_1 = groupContentsStore_1.next()) {\n                                                _d = __read(groupContentsStore_1_1.value, 2), index = _d[0], group = _d[1].group;\n                                                offsets = __spreadArray(__spreadArray([], __read(preceedingZeroWidthEntries.map(function (_a) {\n                                                    var offset = _a.offset;\n                                                    return offset;\n                                                })), false), [\n                                                    value.node.range[0],\n                                                ], false);\n                                                try {\n                                                    for (offsets_1 = (e_5 = void 0, __values(offsets)), offsets_1_1 = offsets_1.next(); !offsets_1_1.done; offsets_1_1 = offsets_1.next()) {\n                                                        offset = offsets_1_1.value;\n                                                        if (group.range[0] >= offset) {\n                                                            newGroupContentsStore.delete(index);\n                                                            break;\n                                                        }\n                                                    }\n                                                }\n                                                catch (e_5_1) { e_5 = { error: e_5_1 }; }\n                                                finally {\n                                                    try {\n                                                        if (offsets_1_1 && !offsets_1_1.done && (_h = offsets_1.return)) _h.call(offsets_1);\n                                                    }\n                                                    finally { if (e_5) throw e_5.error; }\n                                                }\n                                            }\n                                        }\n                                        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                                        finally {\n                                            try {\n                                                if (groupContentsStore_1_1 && !groupContentsStore_1_1.done && (_g = groupContentsStore_1.return)) _g.call(groupContentsStore_1);\n                                            }\n                                            finally { if (e_4) throw e_4.error; }\n                                        }\n                                    }\n                                    groupInfiniteSize = false;\n                                    _loop_3 = function (stackEntry) {\n                                        if (stackEntry.type === 'quantifier' &&\n                                            stackEntry.quantifier.max === undefined) {\n                                            groupInfiniteSize = true;\n                                            return \"continue\";\n                                        }\n                                        else if (stackEntry.type !== 'group') {\n                                            return \"continue\";\n                                        }\n                                        var group = stackEntry.group;\n                                        if (group.behavior === 'lookbehind' ||\n                                            group.behavior === 'negativeLookbehind' ||\n                                            group.behavior === 'negativeLookahead' ||\n                                            group.behavior === 'lookahead') {\n                                            groupInfiniteSize = false;\n                                            return \"continue\";\n                                        }\n                                        if (group.behavior !== 'normal') {\n                                            return \"continue\";\n                                        }\n                                        var index = mustGet(nodeExtra.capturingGroupToIndex, group);\n                                        if (groupInfiniteSize) {\n                                            var newGroupsWithInfiniteSize = new Set(groupsWithInfiniteSize);\n                                            newGroupsWithInfiniteSize.add(index);\n                                            groupsWithInfiniteSize = newGroupsWithInfiniteSize;\n                                        }\n                                        var contents = newGroupContentsStore.get(index) || {\n                                            contents: [],\n                                            group: group,\n                                        };\n                                        newGroupContentsStore.set(index, __assign(__assign({}, contents), { contents: __spreadArray(__spreadArray([], __read(contents.contents), false), [\n                                                __assign(__assign({}, value), { preceedingZeroWidthEntries: preceedingZeroWidthEntries.filter(function (_a) {\n                                                        var offset = _a.offset;\n                                                        // only include entries that are within the group\n                                                        // e.g `^` in (^a) but not `^(a)`\n                                                        return offset >= group.range[0] && offset <= group.range[1];\n                                                    }) }),\n                                            ], false) }));\n                                    };\n                                    try {\n                                        for (_e = (e_6 = void 0, __values(__spreadArray([], __read(value.stack), false).reverse())), _f = _e.next(); !_f.done; _f = _e.next()) {\n                                            stackEntry = _f.value;\n                                            _loop_3(stackEntry);\n                                        }\n                                    }\n                                    catch (e_6_1) { e_6 = { error: e_6_1 }; }\n                                    finally {\n                                        try {\n                                            if (_f && !_f.done && (_j = _e.return)) _j.call(_e);\n                                        }\n                                        finally { if (e_6) throw e_6.error; }\n                                    }\n                                    groupContentsStore = newGroupContentsStore;\n                                    quantifierIterationsAtLastGroup = quantifierIterations;\n                                    return [4 /*yield*/, {\n                                            backreferenceStack: value.stack\n                                                .flatMap(function (stackEntry) {\n                                                return stackEntry.type === 'reference'\n                                                    ? [stackEntry.reference]\n                                                    : [];\n                                            })\n                                                .reverse(),\n                                            characterGroups: value.characterGroups,\n                                            groups: groups,\n                                            lookaheadStack: lookaheadStack,\n                                            node: value.node,\n                                            preceedingZeroWidthEntries: preceedingZeroWidthEntries,\n                                            quantifierStack: quantifierStack,\n                                            type: characterReaderLevel2TypeEntry,\n                                        }];\n                                case 6:\n                                    _k.sent();\n                                    preceedingZeroWidthEntries = [];\n                                    state = {\n                                        characterReader: characterReader,\n                                        groupContentsStore: groupContentsStore,\n                                        groupsWithInfiniteSize: groupsWithInfiniteSize,\n                                        preceedingZeroWidthEntries: preceedingZeroWidthEntries,\n                                        quantifierIterationsAtLastGroup: quantifierIterationsAtLastGroup,\n                                        referenceCharacterReaderWithReference: referenceCharacterReaderWithReference,\n                                    };\n                                    return [3 /*break*/, 7];\n                                case 7: return [2 /*return*/];\n                            }\n                        });\n                    };\n                    _a.label = 1;\n                case 1: return [5 /*yield**/, _loop_2()];\n                case 2:\n                    state_1 = _a.sent();\n                    if (typeof state_1 === \"object\")\n                        return [2 /*return*/, state_1.value];\n                    switch (state_1) {\n                        case \"continue-outer\": return [3 /*break*/, 3];\n                    }\n                    _a.label = 3;\n                case 3: return [3 /*break*/, 1];\n                case 4: return [2 /*return*/];\n            }\n        });\n    };\n    return startThread({\n        characterReader: buildForkableReader(characterReaderLevel1ToInternalReader(buildCharacterReaderLevel1(node))),\n        groupContentsStore: new Map(),\n        groupsWithInfiniteSize: new Set(),\n        preceedingZeroWidthEntries: [],\n        quantifierIterationsAtLastGroup: new Map(),\n        referenceCharacterReaderWithReference: null,\n    });\n}\n\nvar characterReaderLevel3TypeSplit = Symbol('characterReaderLevel3TypeSplit');\nvar characterReaderLevel3TypeEntry = Symbol('characterReaderLevel3TypeEntry');\nfunction isReaderAtEnd(reader) {\n    var isAtEndUnbounded = function (innerReader) {\n        var next = innerReader.next();\n        if (next.done) {\n            return next.value.type === 'end' && !next.value.bounded;\n        }\n        if (next.value.type === characterReaderLevel2TypeSplit) {\n            return (isAtEndUnbounded(next.value.reader()) || isAtEndUnbounded(innerReader));\n        }\n        return false;\n    };\n    return isAtEndUnbounded(fork(reader));\n}\n/**\n * Returns a `CharacterReaderLevel3` which does the same as\n * `CharacterReaderLevel2` but adds an `unbounded` property.\n */\nfunction buildCharacterReaderLevel3(node, nodeExtra) {\n    var startThread = function (reader) {\n        var next, _loop_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _loop_1 = function () {\n                        var value, _b;\n                        return __generator(this, function (_c) {\n                            switch (_c.label) {\n                                case 0:\n                                    value = next.value;\n                                    _b = value.type;\n                                    switch (_b) {\n                                        case characterReaderLevel2TypeEntry: return [3 /*break*/, 1];\n                                        case characterReaderLevel2TypeSplit: return [3 /*break*/, 3];\n                                    }\n                                    return [3 /*break*/, 5];\n                                case 1: return [4 /*yield*/, {\n                                        backreferenceStack: value.backreferenceStack,\n                                        characterGroups: value.characterGroups,\n                                        groups: value.groups,\n                                        lookaheadStack: value.lookaheadStack,\n                                        node: value.node,\n                                        preceedingZeroWidthEntries: value.preceedingZeroWidthEntries,\n                                        quantifierStack: value.quantifierStack,\n                                        type: characterReaderLevel3TypeEntry,\n                                        unbounded: isReaderAtEnd(reader),\n                                    }];\n                                case 2:\n                                    _c.sent();\n                                    return [3 /*break*/, 5];\n                                case 3: return [4 /*yield*/, {\n                                        reader: function () {\n                                            return startThread(buildForkableReader(value.reader()));\n                                        },\n                                        subType: value.subType,\n                                        type: characterReaderLevel3TypeSplit,\n                                    }];\n                                case 4:\n                                    _c.sent();\n                                    return [3 /*break*/, 5];\n                                case 5: return [2 /*return*/];\n                            }\n                        });\n                    };\n                    _a.label = 1;\n                case 1:\n                    if (!!(next = reader.next()).done) return [3 /*break*/, 3];\n                    return [5 /*yield**/, _loop_1()];\n                case 2:\n                    _a.sent();\n                    return [3 /*break*/, 1];\n                case 3: return [2 /*return*/, next.value];\n            }\n        });\n    };\n    return startThread(buildForkableReader(buildCharacterReaderLevel2(node, nodeExtra)));\n}\n\nvar InfiniteLoopTracker = /** @class */ (function () {\n    function InfiniteLoopTracker(isEqual, source) {\n        this._history = [];\n        this._isEqual = isEqual;\n        if (source) {\n            this._history = __spreadArray([], __read(source.getHistory()), false);\n        }\n    }\n    InfiniteLoopTracker.prototype._isEntryEqual = function (a, b) {\n        return this._isEqual(a.left, b.left) && this._isEqual(a.right, b.right);\n    };\n    InfiniteLoopTracker.prototype.append = function (left, right) {\n        this._history.push({ left: left, right: right });\n    };\n    InfiniteLoopTracker.prototype.clone = function () {\n        return new InfiniteLoopTracker(this._isEqual, this);\n    };\n    InfiniteLoopTracker.prototype.getHistory = function () {\n        return __spreadArray([], __read(this._history), false);\n    };\n    InfiniteLoopTracker.prototype.isLooping = function () {\n        var length = this._history.length;\n        outer: for (var candidateSize = 1; candidateSize <= length / 2; candidateSize++) {\n            var candidateStart = length - candidateSize * 2;\n            for (var i = 0; i < candidateSize; i++) {\n                if (!this._isEntryEqual(this._history[candidateStart + i], this._history[candidateStart + candidateSize + i])) {\n                    continue outer;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    return InfiniteLoopTracker;\n}());\n\nfunction once(fn) {\n    var done = false;\n    var res;\n    return function () {\n        if (!done) {\n            done = true;\n            res = fn();\n        }\n        return res;\n    };\n}\n\nvar ResultCache = /** @class */ (function () {\n    function ResultCache() {\n        this._cache = new Map();\n    }\n    ResultCache.prototype.addResult = function (a, b, result) {\n        var mapA = this._cache.get(a) || new Map();\n        mapA.set(b, result);\n        this._cache.set(a, mapA);\n        var mapB = this._cache.get(b) || new Map();\n        mapB.set(a, result);\n        this._cache.set(b, mapB);\n    };\n    ResultCache.prototype.getResult = function (a, b) {\n        var _a;\n        return (_a = this._cache.get(a)) === null || _a === void 0 ? void 0 : _a.get(b);\n    };\n    return ResultCache;\n}());\n\nvar SidesEqualChecker = /** @class */ (function () {\n    function SidesEqualChecker() {\n        this._cache = new ResultCache();\n    }\n    SidesEqualChecker.prototype.areSidesEqual = function (left, right) {\n        var cached = this._cache.getResult(left, right);\n        if (cached !== undefined)\n            return cached;\n        var equal = left.node === right.node &&\n            areArraysEqual(left.backreferenceStack, right.backreferenceStack) &&\n            areMapsEqual(buildQuantifierIterations(left.quantifierStack), buildQuantifierIterations(right.quantifierStack));\n        this._cache.addResult(left, right, equal);\n        return equal;\n    };\n    return SidesEqualChecker;\n}());\n\nvar checkerReaderTypeTrail = Symbol('checkerReaderTypeTrail');\nvar checkerReaderTypeInfiniteLoop = Symbol('checkerReaderTypeInfiniteLoop');\nvar stackOverflowLimit = 1000;\nvar isNodeWithQuantifierTrailEqual = function (left, right) {\n    return left.node === right.node && left.quantifierTrail === right.quantifierTrail;\n};\n/**\n * Takes a left and right `CharacterReaderLevel3` and runs them against each other.\n *\n * Emits a trail when left and right differ, as it means there are 2 different ways of matching the same\n * trail up to that point.\n */\nfunction buildCheckerReader(input) {\n    var sidesEqualChecker, trails, stepCount, latestEndTime, timedOut, stackOverflow, initialLeftStreamReader, initialRightStreamReader, stack, _loop_1, state_1;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                sidesEqualChecker = new SidesEqualChecker();\n                trails = new Set();\n                stepCount = 0;\n                latestEndTime = Date.now() + input.timeout;\n                timedOut = false;\n                stackOverflow = false;\n                initialLeftStreamReader = buildForkableReader(input.leftStreamReader);\n                initialRightStreamReader = buildForkableReader(input.rightStreamReader);\n                stack = [\n                    {\n                        infiniteLoopTracker: new InfiniteLoopTracker(isNodeWithQuantifierTrailEqual),\n                        streamReadersWithGetters: [\n                            {\n                                get: once(function () { return initialLeftStreamReader.next(); }),\n                                reader: initialLeftStreamReader,\n                            },\n                            {\n                                get: once(function () { return initialRightStreamReader.next(); }),\n                                reader: initialRightStreamReader,\n                            },\n                        ],\n                        trail: [],\n                    },\n                ];\n                _loop_1 = function () {\n                    var entry, streamReadersWithGetters, infiniteLoopTracker, trail, nextValues, _loop_2, i, state_2, _b, leftNextValue, rightNextValue, leftValue, rightValue, leftPassedStartAnchor, rightPassedStartAnchor, somethingPassedStartAnchor, leftLookahead, rightLookahead, leftQuantifiersInInfiniteProportion, rightQuantifiersInInfiniteProportion, leftAndRightIdentical, intersection, leftAtomicGroups, rightAtomicGroups, newEntry, shouldSendTrail;\n                    return __generator(this, function (_c) {\n                        switch (_c.label) {\n                            case 0:\n                                timedOut = Date.now() > latestEndTime;\n                                stackOverflow = stack.length > stackOverflowLimit;\n                                if (timedOut || stackOverflow) {\n                                    return [2 /*return*/, \"break\"];\n                                }\n                                entry = stack.pop();\n                                if (!entry)\n                                    return [2 /*return*/, \"break\"];\n                                streamReadersWithGetters = entry.streamReadersWithGetters;\n                                infiniteLoopTracker = entry.infiniteLoopTracker, trail = entry.trail;\n                                nextValues = [];\n                                _loop_2 = function (i) {\n                                    var result = streamReadersWithGetters[i].get();\n                                    if (!result.done &&\n                                        result.value.type === characterReaderLevel3TypeSplit) {\n                                        var value_1 = result.value;\n                                        stack.push({\n                                            infiniteLoopTracker: infiniteLoopTracker,\n                                            streamReadersWithGetters: streamReadersWithGetters.map(function (_a, j) {\n                                                var reader = _a.reader, get = _a.get;\n                                                return ({\n                                                    get: j === i ? once(function () { return reader.next(); }) : get,\n                                                    reader: reader,\n                                                });\n                                            }),\n                                            trail: trail,\n                                        });\n                                        var newStreamReadersWithGetters = streamReadersWithGetters.map(function (_a, j) {\n                                            var reader = _a.reader, get = _a.get;\n                                            var newReader = j === i ? buildForkableReader(value_1.reader()) : fork(reader);\n                                            return {\n                                                get: j < i ? get : once(function () { return newReader.next(); }),\n                                                reader: newReader,\n                                            };\n                                        });\n                                        stack.push({\n                                            infiniteLoopTracker: infiniteLoopTracker.clone(),\n                                            streamReadersWithGetters: newStreamReadersWithGetters,\n                                            trail: trail,\n                                        });\n                                        return \"continue-outer\";\n                                    }\n                                    else {\n                                        nextValues.push(result);\n                                    }\n                                };\n                                for (i = 0; i < streamReadersWithGetters.length; i++) {\n                                    state_2 = _loop_2(i);\n                                    switch (state_2) {\n                                        case \"continue-outer\": return [2 /*return*/, state_2];\n                                    }\n                                }\n                                _b = __read(nextValues, 2), leftNextValue = _b[0], rightNextValue = _b[1];\n                                if (++stepCount > input.maxSteps ||\n                                    leftNextValue.done ||\n                                    rightNextValue.done) {\n                                    return [2 /*return*/, \"continue\"];\n                                }\n                                /* istanbul ignore next */\n                                if (leftNextValue.value.type === characterReaderLevel3TypeSplit ||\n                                    rightNextValue.value.type === characterReaderLevel3TypeSplit) {\n                                    throw new Error('Internal error: impossible leftValue/rightValue type');\n                                }\n                                leftValue = leftNextValue.value;\n                                rightValue = rightNextValue.value;\n                                leftPassedStartAnchor = leftValue.preceedingZeroWidthEntries.some(function (_a) {\n                                    var type = _a.type;\n                                    return type === 'start';\n                                });\n                                rightPassedStartAnchor = rightValue.preceedingZeroWidthEntries.some(function (_a) {\n                                    var type = _a.type;\n                                    return type === 'start';\n                                });\n                                somethingPassedStartAnchor = leftPassedStartAnchor || rightPassedStartAnchor;\n                                if ((trail.length > 0 && somethingPassedStartAnchor) ||\n                                    leftPassedStartAnchor !== rightPassedStartAnchor) {\n                                    return [2 /*return*/, \"continue\"];\n                                }\n                                leftLookahead = last(leftValue.lookaheadStack);\n                                rightLookahead = last(rightValue.lookaheadStack);\n                                if (leftLookahead !== rightLookahead) {\n                                    return [2 /*return*/, \"continue\"];\n                                }\n                                leftQuantifiersInInfiniteProportion = buildQuantifiersInInfinitePortion(leftValue.quantifierStack);\n                                rightQuantifiersInInfiniteProportion = buildQuantifiersInInfinitePortion(rightValue.quantifierStack);\n                                if (setsOverlap(leftQuantifiersInInfiniteProportion, rightQuantifiersInInfiniteProportion)) {\n                                    leftAndRightIdentical = trail.every(function (_a) {\n                                        var left = _a.left, right = _a.right;\n                                        return sidesEqualChecker.areSidesEqual(left, right);\n                                    });\n                                    if (leftAndRightIdentical) {\n                                        return [2 /*return*/, \"continue\"];\n                                    }\n                                }\n                                if (leftQuantifiersInInfiniteProportion.size &&\n                                    rightQuantifiersInInfiniteProportion.size) {\n                                    infiniteLoopTracker.append({\n                                        node: leftValue.node,\n                                        quantifierTrail: buildQuantifierTrail(leftValue.quantifierStack, true),\n                                    }, {\n                                        node: rightValue.node,\n                                        quantifierTrail: buildQuantifierTrail(rightValue.quantifierStack, true),\n                                    });\n                                }\n                                else {\n                                    infiniteLoopTracker = new InfiniteLoopTracker(isNodeWithQuantifierTrailEqual);\n                                }\n                                if (!infiniteLoopTracker.isLooping()) return [3 /*break*/, 3];\n                                if (!(leftValue.node === rightValue.node)) return [3 /*break*/, 2];\n                                return [4 /*yield*/, { type: checkerReaderTypeInfiniteLoop }];\n                            case 1:\n                                _c.sent();\n                                _c.label = 2;\n                            case 2: return [2 /*return*/, \"continue\"];\n                            case 3:\n                                intersection = intersectCharacterGroups([leftValue, rightValue].map(function (_a) {\n                                    var characterGroups = _a.characterGroups;\n                                    return characterGroups;\n                                }));\n                                if (isEmptyCharacterGroups(intersection)) {\n                                    return [2 /*return*/, \"continue\"];\n                                }\n                                leftAtomicGroups = new Set(__spreadArray([], __read(leftValue.groups.keys()), false).filter(function (group) {\n                                    return input.atomicGroupOffsets.has(group.range[0]);\n                                }));\n                                rightAtomicGroups = new Set(__spreadArray([], __read(rightValue.groups.keys()), false).filter(function (group) {\n                                    return input.atomicGroupOffsets.has(group.range[0]);\n                                }));\n                                if (!areSetsEqual(leftAtomicGroups, rightAtomicGroups)) {\n                                    return [2 /*return*/, \"continue\"];\n                                }\n                                newEntry = {\n                                    intersection: intersection,\n                                    left: {\n                                        backreferenceStack: leftValue.backreferenceStack,\n                                        node: leftValue.node,\n                                        quantifierStack: leftValue.quantifierStack,\n                                    },\n                                    right: {\n                                        backreferenceStack: rightValue.backreferenceStack,\n                                        node: rightValue.node,\n                                        quantifierStack: rightValue.quantifierStack,\n                                    },\n                                };\n                                trail = __spreadArray(__spreadArray([], __read(trail), false), [newEntry], false);\n                                if (!\n                                // if both sides are unbounded then it means a backtrack won't occur\n                                // from one side to the other if an invalid character is hit (e.g. `^a*a*`),\n                                // so don't emit the trail\n                                ((!leftValue.unbounded || !rightValue.unbounded) &&\n                                    !sidesEqualChecker.areSidesEqual(newEntry.left, newEntry.right))) \n                                // if both sides are unbounded then it means a backtrack won't occur\n                                // from one side to the other if an invalid character is hit (e.g. `^a*a*`),\n                                // so don't emit the trail\n                                return [3 /*break*/, 5];\n                                shouldSendTrail = function () {\n                                    if (!trails.has(trail)) {\n                                        var alreadyExists = __spreadArray([], __read(trails), false).some(function (existingTrail) {\n                                            if (existingTrail.length !== trail.length)\n                                                return false;\n                                            return (existingTrail.every(function (existingEntry, i) {\n                                                return sidesEqualChecker.areSidesEqual(existingEntry.left, trail[i].right) &&\n                                                    sidesEqualChecker.areSidesEqual(existingEntry.right, trail[i].left);\n                                            }) ||\n                                                existingTrail.every(function (existingEntry, i) {\n                                                    return sidesEqualChecker.areSidesEqual(existingEntry.left, trail[i].left) &&\n                                                        sidesEqualChecker.areSidesEqual(existingEntry.right, trail[i].right);\n                                                }));\n                                        });\n                                        if (!alreadyExists) {\n                                            return true;\n                                        }\n                                    }\n                                    return false;\n                                };\n                                if (!shouldSendTrail()) return [3 /*break*/, 5];\n                                trails.add(trail);\n                                return [4 /*yield*/, { trail: trail, type: checkerReaderTypeTrail }];\n                            case 4:\n                                _c.sent();\n                                _c.label = 5;\n                            case 5:\n                                stack.push({\n                                    infiniteLoopTracker: infiniteLoopTracker,\n                                    streamReadersWithGetters: streamReadersWithGetters.map(function (_a) {\n                                        var reader = _a.reader;\n                                        return ({\n                                            get: once(function () { return reader.next(); }),\n                                            reader: reader,\n                                        });\n                                    }),\n                                    trail: trail,\n                                });\n                                return [2 /*return*/];\n                        }\n                    });\n                };\n                _a.label = 1;\n            case 1: return [5 /*yield**/, _loop_1()];\n            case 2:\n                state_1 = _a.sent();\n                if (state_1 === \"break\")\n                    return [3 /*break*/, 4];\n                switch (state_1) {\n                    case \"continue-outer\": return [3 /*break*/, 3];\n                }\n                _a.label = 3;\n            case 3: return [3 /*break*/, 1];\n            case 4: return [2 /*return*/, {\n                    error: stepCount > input.maxSteps\n                        ? 'hitMaxSteps'\n                        : // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                            timedOut\n                                ? 'timedOut'\n                                : // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                                    stackOverflow\n                                        ? 'stackOverflow'\n                                        : null,\n                }];\n        }\n    });\n}\n\nvar lookaheadBehaviours$1 = [\n    'lookahead',\n    'lookbehind',\n    'negativeLookahead',\n    'negativeLookbehind',\n];\nfunction buildNodeExtra(regexp) {\n    var capturingGroupToIndex = new Map();\n    var indexToCapturingGroup = new Map();\n    var nodeToLookaheadStack = new Map();\n    var visit = function (node, lookaheadStack) {\n        switch (node.type) {\n            case 'anchor':\n            case 'characterClass':\n            case 'characterClassEscape':\n            case 'characterClassRange':\n            case 'unicodePropertyEscape':\n            case 'value':\n            case 'dot':\n                return;\n            case 'reference': {\n                nodeToLookaheadStack.set(node, lookaheadStack);\n                break;\n            }\n            case 'alternative':\n            case 'disjunction': {\n                node.body.forEach(function (expression) { return visit(expression, lookaheadStack); });\n                return;\n            }\n            case 'group': {\n                if (node.behavior === 'normal') {\n                    var index = capturingGroupToIndex.size + 1;\n                    capturingGroupToIndex.set(node, index);\n                    indexToCapturingGroup.set(index, node);\n                    nodeToLookaheadStack.set(node, lookaheadStack);\n                }\n                var newLookaheadStack_1 = __spreadArray([], __read(lookaheadStack), false);\n                if (node.behavior !== 'normal' &&\n                    lookaheadBehaviours$1.indexOf(node.behavior) >= 0) {\n                    newLookaheadStack_1.push(node);\n                }\n                node.body.forEach(function (expression) { return visit(expression, newLookaheadStack_1); });\n                return;\n            }\n            case 'quantifier': {\n                node.body.forEach(function (expression) { return visit(expression, lookaheadStack); });\n                return;\n            }\n        }\n    };\n    visit(regexp, []);\n    return {\n        capturingGroupToIndex: capturingGroupToIndex,\n        indexToCapturingGroup: indexToCapturingGroup,\n        nodeToLookaheadStack: nodeToLookaheadStack,\n    };\n}\n\nfunction collectResults(_a) {\n    var atomicGroupOffsets = _a.atomicGroupOffsets, node = _a.node, maxBacktracks = _a.maxBacktracks, maxSteps = _a.maxSteps, timeout = _a.timeout;\n    var nodeExtra = buildNodeExtra(node);\n    var leftStreamReader = buildCharacterReaderLevel3(node, nodeExtra);\n    var rightStreamReader = buildCharacterReaderLevel3(node, nodeExtra);\n    var reader = buildCheckerReader({\n        atomicGroupOffsets: atomicGroupOffsets,\n        leftStreamReader: leftStreamReader,\n        maxSteps: maxSteps,\n        rightStreamReader: rightStreamReader,\n        timeout: timeout,\n    });\n    var trails = [];\n    var next;\n    var infiniteBacktracks = false;\n    var _loop_1 = function () {\n        switch (next.value.type) {\n            case checkerReaderTypeInfiniteLoop: {\n                infiniteBacktracks = true;\n                if (trails.length > 0) {\n                    return \"break-outer\";\n                }\n                break;\n            }\n            case checkerReaderTypeTrail: {\n                var trail_1 = next.value.trail;\n                trails = trails.filter(function (existingTrail) {\n                    var samePrefix = trail_1.length >= existingTrail.length &&\n                        areArraysEqual(trail_1.slice(0, existingTrail.length), existingTrail);\n                    return !samePrefix;\n                });\n                trails = __spreadArray(__spreadArray([], __read(trails), false), [trail_1], false);\n                if (infiniteBacktracks || trails.length > maxBacktracks) {\n                    return \"break-outer\";\n                }\n                break;\n            }\n        }\n    };\n    outer: while (!(next = reader.next()).done) {\n        var state_1 = _loop_1();\n        switch (state_1) {\n            case \"break-outer\": break outer;\n        }\n    }\n    var worstCaseBacktrackCount = infiniteBacktracks ? Infinity : trails.length;\n    var error = null;\n    if (next.done) {\n        if (next.value.error) {\n            worstCaseBacktrackCount = Infinity;\n            error = next.value.error;\n        }\n        else if (!trails.length) {\n            worstCaseBacktrackCount = 0;\n        }\n    }\n    else {\n        worstCaseBacktrackCount = Infinity;\n        error = 'hitMaxBacktracks';\n    }\n    return {\n        error: error,\n        trails: trails,\n        worstCaseBacktrackCount: worstCaseBacktrackCount,\n    };\n}\n\nvar lookaheadBehaviours = [\n    'lookahead',\n    'lookbehind',\n    'negativeLookahead',\n    'negativeLookbehind',\n];\nfunction replace(input, replacement, start, end) {\n    return \"\".concat(input.slice(0, start)).concat(replacement).concat(input.slice(end));\n}\nfunction quantifierIterationsToString(quantifier) {\n    if (quantifier.symbol) {\n        return \"\".concat(quantifier.symbol).concat(quantifier.greedy ? '' : '?');\n    }\n    if (quantifier.min === quantifier.max) {\n        return \"{\".concat(quantifier.min, \"}\");\n    }\n    return \"{\".concat(quantifier.min, \",\").concat(quantifier.max || '', \"}\").concat(quantifier.greedy ? '' : '?');\n}\nfunction getRawWithoutCapturingGroupsOrLookaheads(rootNode) {\n    var referencesWithOffset = new Map();\n    var walk = function (node, offset) {\n        var walkAll = function (nodes, startOffset) {\n            var result = '';\n            nodes.forEach(function (a) {\n                result += walk(a, startOffset + result.length);\n            });\n            return result;\n        };\n        switch (node.type) {\n            case 'anchor':\n            case 'characterClass':\n            case 'characterClassEscape':\n            case 'unicodePropertyEscape':\n            case 'value':\n            case 'dot':\n                return node.raw;\n            case 'reference': {\n                referencesWithOffset.set(node, offset);\n                return node.raw;\n            }\n            case 'group': {\n                switch (node.behavior) {\n                    case 'normal':\n                        return \"(?:\".concat(walkAll(node.body, offset + 3), \")\");\n                    case 'ignore':\n                        return \"(?:\".concat(walkAll(node.body, offset + 3), \")\");\n                    case 'lookahead':\n                    case 'lookbehind':\n                    case 'negativeLookahead':\n                    case 'negativeLookbehind':\n                        return '';\n                }\n            }\n            // eslint-disable-next-line no-fallthrough\n            case 'disjunction': {\n                var res_1 = '';\n                node.body.forEach(function (a, i) {\n                    if (i > 0)\n                        res_1 += '|';\n                    res_1 += walk(a, offset + res_1.length);\n                });\n                return res_1;\n            }\n            case 'alternative':\n                return walkAll(node.body, offset);\n            case 'quantifier': {\n                return \"\".concat(walk(node.body[0], offset)).concat(quantifierIterationsToString(node));\n            }\n        }\n    };\n    var result = walk(rootNode, 0);\n    return {\n        referencesWithOffset: referencesWithOffset,\n        result: result,\n    };\n}\n/**\n * Downgrade the provided pattern if needed so that it is supported\n * for checking.\n *\n * A downgraded pattern may introduce false positives.\n *\n * This does the following:\n * - If the pattern contains a reference to a group that lives in a positive lookahead,\n *   the reference will be replaced with a non-capturing group that contains referenced group.\n * - If the pattern contains a reference to a group that is a non-finite size,\n *   the reference will be replaced with a non-capturing group that contains the referenced group.\n */\nfunction downgradePattern(_a) {\n    var pattern = _a.pattern, unicode = _a.unicode;\n    var run = function (lastResult) {\n        var ast = parse(lastResult.pattern, unicode);\n        var actions = [];\n        var groups = new Map();\n        var infiniteGroups = new Set();\n        var nextGroupIndex = 1;\n        var lookaheadOnlyContainsGroup = function (lookahead, group) {\n            if (lookahead.body.length !== 1)\n                return false;\n            var node = lookahead.body[0];\n            return node === group;\n        };\n        var walkAll = function (nodes, nodeStack, serial) {\n            var justHadLookahead = null;\n            nodes.forEach(function (expression) {\n                if (serial) {\n                    // eslint-disable-next-line no-use-before-define\n                    walk(expression, nodeStack, justHadLookahead);\n                    justHadLookahead =\n                        expression.type === 'group' && expression.behavior === 'lookahead'\n                            ? expression\n                            : null;\n                }\n                else {\n                    // eslint-disable-next-line no-use-before-define\n                    walk(expression, nodeStack, null);\n                }\n            });\n        };\n        var walk = function (node, nodeStack, immediatelyPreceedingLookahead) {\n            switch (node.type) {\n                case 'anchor':\n                case 'characterClass':\n                case 'characterClassEscape':\n                case 'unicodePropertyEscape':\n                case 'value':\n                case 'dot':\n                    return;\n                case 'group': {\n                    var groupIndex = null;\n                    if (node.behavior === 'normal') {\n                        groupIndex = nextGroupIndex;\n                        nextGroupIndex++;\n                    }\n                    walkAll(node.body, __spreadArray(__spreadArray([], __read(nodeStack), false), [node], false), true);\n                    if (groupIndex !== null && node.behavior === 'normal') {\n                        groups.set(groupIndex, { group: node, stack: __spreadArray([], __read(nodeStack), false) });\n                    }\n                    return;\n                }\n                case 'disjunction': {\n                    walkAll(node.body, __spreadArray(__spreadArray([], __read(nodeStack), false), [node], false), false);\n                    return;\n                }\n                case 'alternative': {\n                    walkAll(node.body, __spreadArray(__spreadArray([], __read(nodeStack), false), [node], false), true);\n                    return;\n                }\n                case 'quantifier': {\n                    if (node.max === undefined) {\n                        __spreadArray([], __read(nodeStack), false).reverse().some(function (stackNode) {\n                            if (stackNode.type === 'group') {\n                                if (lookaheadBehaviours.indexOf(stackNode.behavior) >= 0) {\n                                    // this infinite quantifier is contained in a lookahead,\n                                    // so doesn't effect outer group size\n                                    return true;\n                                }\n                                infiniteGroups.add(stackNode);\n                            }\n                            return false;\n                        });\n                    }\n                    walkAll(node.body, __spreadArray(__spreadArray([], __read(nodeStack), false), [node], false), false);\n                    return;\n                }\n                case 'reference': {\n                    var entry = groups.get(node.matchIndex);\n                    if (entry) {\n                        var group = entry.group, stack = entry.stack;\n                        var localStack = dropCommon(stack, nodeStack).a;\n                        var lookaheadStack = localStack.flatMap(function (stackNode) {\n                            return stackNode.type === 'group' &&\n                                lookaheadBehaviours.indexOf(stackNode.behavior) >= 0\n                                ? [stackNode]\n                                : [];\n                        });\n                        var groupMayNotBeReached = localStack.some(function (stackNode) {\n                            return stackNode.type === 'disjunction' ||\n                                (stackNode.type === 'quantifier' && stackNode.min === 0);\n                        });\n                        var groupInLookahead = lookaheadStack.length > 0;\n                        var groupCouldBeSet = lookaheadStack.every(function (value) {\n                            return value.behavior !== 'negativeLookahead' &&\n                                value.behavior !== 'negativeLookbehind';\n                        });\n                        if (groupCouldBeSet &&\n                            (groupInLookahead || infiniteGroups.has(group))) {\n                            // if we have something like `a(?=(bc))\\1`\n                            // `\\1`, and therefore the group we inline in its place, can be considered atomic\n                            // given that lookaheads can't be backtracked into and immediately after the\n                            // lookahead we match the same that was in the lookahead\n                            var atomic = !!immediatelyPreceedingLookahead &&\n                                lookaheadOnlyContainsGroup(immediatelyPreceedingLookahead, group);\n                            var optional = groupInLookahead && groupMayNotBeReached;\n                            actions.push({\n                                atomicOrOptional: atomic\n                                    ? 'atomic'\n                                    : optional\n                                        ? 'optional'\n                                        : null,\n                                group: group,\n                                optional: groupInLookahead && groupMayNotBeReached,\n                                reference: node,\n                            });\n                        }\n                    }\n                    return;\n                }\n            }\n        };\n        walk(ast, [], null);\n        var newPattern = lastResult.pattern;\n        var atomicGroupOffsets = new Set(lastResult.atomicGroupOffsets);\n        var needToRerun = false;\n        __spreadArray([], __read(actions), false).sort(function (a, b) { return b.reference.range[0] - a.reference.range[0]; })\n            .forEach(function (action) {\n            var atomicOrOptional = action.atomicOrOptional, group = action.group, _a = __read(action.reference.range, 2), referenceStart = _a[0], referenceEnd = _a[1];\n            var _b = getRawWithoutCapturingGroupsOrLookaheads(group), result = _b.result, referencesWithOffset = _b.referencesWithOffset;\n            if (referencesWithOffset.size > 0) {\n                needToRerun = true;\n            }\n            var replacement = atomicOrOptional === 'optional' ? \"(?:\".concat(result, \"?)\") : result;\n            newPattern = replace(newPattern, replacement, referenceStart, referenceEnd);\n            var shiftAmount = replacement.length - (referenceEnd - referenceStart);\n            atomicGroupOffsets = new Set(__spreadArray([], __read(atomicGroupOffsets), false).map(function (offset) {\n                return offset > referenceStart ? offset + shiftAmount : offset;\n            }));\n            if (atomicOrOptional === 'atomic') {\n                atomicGroupOffsets.add(referenceStart);\n            }\n            actions.forEach(function (_a) {\n                var innerAtomicOrOptional = _a.atomicOrOptional, innerReference = _a.reference;\n                if (innerAtomicOrOptional === 'atomic') {\n                    var offset = referencesWithOffset.get(innerReference);\n                    if (offset !== undefined) {\n                        atomicGroupOffsets.add(referenceStart + offset);\n                    }\n                }\n            });\n        });\n        return { needToRerun: needToRerun, result: { atomicGroupOffsets: atomicGroupOffsets, pattern: newPattern } };\n    };\n    var lastResult = {\n        atomicGroupOffsets: new Set(),\n        pattern: pattern,\n    };\n    for (;;) {\n        var _b = run(lastResult), result = _b.result, needToRerun = _b.needToRerun;\n        lastResult = result;\n        if (!needToRerun) {\n            return result;\n        }\n    }\n}\n\nvar defaultResultsLimit = 15;\nfunction getBreadcrumbs(side) {\n    return \"\".concat(__spreadArray(__spreadArray([], __read(side.backreferenceStack.map(function (_a) {\n        var node = _a.node;\n        return node.start.offset;\n    }).reverse()), false), [\n        side.node.start.offset,\n    ], false).join(\"\\u2192\"));\n}\n/**\n * Takes a result and converts it to a text representation.\n *\n * Do not try and parse this string programatically. It may change\n * between any version.\n */\nfunction toFriendly(result, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.resultsLimit, resultsLimit = _c === void 0 ? defaultResultsLimit : _c, _d = _b.alwaysIncludeTrails, alwaysIncludeTrails = _d === void 0 ? false : _d;\n    if (resultsLimit < 0) {\n        throw new Error('`resultsLimit` must be > 0.');\n    }\n    var backtrackCountString = result.worstCaseBacktrackCount.infinite ||\n        result.worstCaseBacktrackCount.value > 0\n        ? \"There could be \".concat(!result.worstCaseBacktrackCount.infinite ? 'at most ' : '').concat(result.worstCaseBacktrackCount.infinite\n            ? 'infinite backtracks'\n            : result.worstCaseBacktrackCount.value === 1\n                ? '1 backtrack'\n                : \"\".concat(result.worstCaseBacktrackCount.value, \" backtracks\"), \".\")\n        : null;\n    if (result.safe && !alwaysIncludeTrails) {\n        return \"Regex is safe.\".concat(backtrackCountString ? \" \".concat(backtrackCountString) : '');\n    }\n    var outputLines = [];\n    if (result.patternDowngraded) {\n        outputLines.push(\"Pattern was downgraded to `\".concat(result.pattern, \"`.\"));\n    }\n    if (!result.trails.length) {\n        var parts = [];\n        parts.push(result.safe ? 'Regex is safe.' : 'Regex may not be safe.');\n        if (result.error === 'timedOut') {\n            parts.push(\"Timed out.\");\n        }\n        if (result.error === 'hitMaxSteps') {\n            parts.push(\"Reached steps limit.\");\n        }\n        if (result.error === 'stackOverflow') {\n            parts.push(\"Stack overflow.\");\n        }\n        if (!result.safe) {\n            parts.push(\"The pattern may have too many variations.\");\n        }\n        outputLines.push(parts.join(' '));\n    }\n    else {\n        var resultBlocks = result.trails\n            .slice(0, resultsLimit)\n            .map(function (_a) {\n            var trail = _a.trail;\n            var rowContents = trail.map(function (_a) {\n                var a = _a.a, b = _a.b;\n                return [\n                    getBreadcrumbs(a),\n                    \"`\".concat(a.node.source, \"`\"),\n                    getBreadcrumbs(b),\n                    \"`\".concat(b.node.source, \"`\"),\n                ];\n            });\n            var maxCol1Length = Math.max.apply(Math, __spreadArray([], __read(rowContents.map(function (_a) {\n                var _b = __read(_a, 1), col = _b[0];\n                return col.length;\n            })), false));\n            var maxCol2Length = Math.max.apply(Math, __spreadArray([], __read(rowContents.map(function (_a) {\n                var _b = __read(_a, 2), col = _b[1];\n                return col.length;\n            })), false));\n            var maxCol3Length = Math.max.apply(Math, __spreadArray([], __read(rowContents.map(function (_a) {\n                var _b = __read(_a, 3), col = _b[2];\n                return col.length;\n            })), false));\n            var rows = rowContents.map(function (_a) {\n                var _b = __read(_a, 4), col1 = _b[0], col2 = _b[1], col3 = _b[2], col4 = _b[3];\n                return \"\".concat(col1.padStart(maxCol1Length), \": \").concat(col2.padEnd(maxCol2Length), \" | \").concat(col3.padStart(maxCol3Length), \": \").concat(col4);\n            });\n            var maxRowLength = Math.max.apply(Math, __spreadArray([], __read(rows.map(function (row) { return row.length; })), false));\n            rows.push('='.repeat(maxRowLength));\n            return rows.join('\\n');\n        });\n        var errorToMessage = {\n            hitMaxBacktracks: 'Hit maximum number of backtracks so there may be more results than shown here.',\n            hitMaxSteps: 'Hit maximum number of steps so there may be more results than shown here.',\n            stackOverflow: 'Stack overflow occurred. Regex may have too much branching.',\n            timedOut: 'Timed out so there may be more results than shown here.',\n        };\n        outputLines.push.apply(outputLines, __spreadArray([], __read(__spreadArray([\n            \"Regex is \".concat(!result.safe ? 'not ' : '', \"safe.\").concat(backtrackCountString ? \" \".concat(backtrackCountString) : '')\n        ], __read((resultsLimit > 0\n            ? __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([\n                '',\n                \"The following trail\".concat(result.trails.length > 1 ? 's' : '', \" show\").concat(result.trails.length === 1 ? 's' : '', \" how the same input can be matched multiple ways.\")\n            ], __read(resultBlocks), false), [\n                ''\n            ], false), __read((result.error ? [errorToMessage[result.error]] : [])), false), [\n                \"Note there may be more results than shown here as some infinite loops are detected and removed.\"\n            ], false), __read((result.trails.length > resultsLimit\n                ? ['There are more results than this but hit results limit.']\n                : [])), false) : [])), false)), false));\n    }\n    return outputLines.join('\\n');\n}\n\n/**\n * The current version.\n */\nvar version = _version;\nvar defaultTimeout = Infinity;\nvar defaultMaxBacktracks = 200;\nvar defaultMaxSteps = 20000;\nvar defaultUnicode = false;\nvar supportedJSFlags = new Set(['u', 'g', 's', 'y']);\nfunction toRedosDetectorNode(node) {\n    return {\n        end: { offset: node.range[1] },\n        source: node.raw,\n        start: { offset: node.range[0] },\n    };\n}\nfunction toRedosDetectorBackReferenceStack(backreferenceStack) {\n    return backreferenceStack.map(function (reference) {\n        return {\n            index: reference.matchIndex,\n            node: toRedosDetectorNode(reference),\n        };\n    });\n}\nfunction toRedosDetectorQuantifierIterations(stack) {\n    return stack.map(function (_a) {\n        var quantifier = _a.quantifier, iteration = _a.iteration;\n        return {\n            iteration: iteration,\n            node: toRedosDetectorNode(quantifier),\n        };\n    });\n}\n/**\n * Check if the provided input pattern is not susceptible to ReDoS attacks.\n *\n * Can be configured with various options in the second argument.\n */\nfunction isSafePattern(inputPattern, _a) {\n    var _b = _a === void 0 ? {} : _a, atomicGroupOffsetsInput = _b.atomicGroupOffsets, _c = _b.maxBacktracks, maxBacktracks = _c === void 0 ? defaultMaxBacktracks : _c, _d = _b.maxSteps, maxSteps = _d === void 0 ? defaultMaxSteps : _d, _e = _b.timeout, timeout = _e === void 0 ? defaultTimeout : _e, _f = _b.unicode, unicode = _f === void 0 ? defaultUnicode : _f, _g = _b.downgradePattern, downgradePattern$1 = _g === void 0 ? true : _g;\n    if (downgradePattern$1 && atomicGroupOffsetsInput) {\n        throw new Error('`atomicGroupOffsets` cannot be used with `downgradePattern: true`.');\n    }\n    if (timeout <= 0) {\n        throw new Error('`timeout` must be a positive number.');\n    }\n    if (maxBacktracks < 0) {\n        throw new Error('`maxBacktracks` must be a positive number or 0.');\n    }\n    if (maxSteps <= 0) {\n        throw new Error('`maxSteps` must be a positive number.');\n    }\n    var _h = downgradePattern$1\n        ? downgradePattern({ pattern: inputPattern, unicode: unicode })\n        : {\n            atomicGroupOffsets: new Set(atomicGroupOffsetsInput || []),\n            pattern: inputPattern,\n        }, pattern = _h.pattern, atomicGroupOffsets = _h.atomicGroupOffsets;\n    var patternDowngraded = downgradePattern$1 && inputPattern !== pattern;\n    var ast = parse(pattern, unicode);\n    var result = collectResults({\n        atomicGroupOffsets: atomicGroupOffsets,\n        maxBacktracks: maxBacktracks,\n        maxSteps: maxSteps,\n        node: ast,\n        timeout: timeout,\n    });\n    return __assign(__assign({}, (result.error\n        ? {\n            error: result.error,\n            safe: false,\n        }\n        : {\n            error: null,\n            safe: true,\n        })), { pattern: pattern, patternDowngraded: patternDowngraded, trails: result.trails.map(function (trail) {\n            var safeRegexTrail = {\n                trail: trail.map(function (_a) {\n                    var left = _a.left, right = _a.right;\n                    var entry = {\n                        a: {\n                            backreferenceStack: toRedosDetectorBackReferenceStack(right.backreferenceStack),\n                            node: toRedosDetectorNode(right.node),\n                            quantifierIterations: toRedosDetectorQuantifierIterations(right.quantifierStack),\n                        },\n                        b: {\n                            backreferenceStack: toRedosDetectorBackReferenceStack(left.backreferenceStack),\n                            node: toRedosDetectorNode(left.node),\n                            quantifierIterations: toRedosDetectorQuantifierIterations(left.quantifierStack),\n                        },\n                    };\n                    return entry;\n                }),\n            };\n            return safeRegexTrail;\n        }), worstCaseBacktrackCount: result.worstCaseBacktrackCount === Infinity\n            ? { infinite: true }\n            : { infinite: false, value: result.worstCaseBacktrackCount } });\n}\n/**\n * Check if the provided regular expression object is not susceptible to ReDoS attacks.\n *\n * Can be configured with various options in the second argument.\n */\nfunction isSafe(regexp, config) {\n    var e_1, _a;\n    var unicode = false;\n    try {\n        for (var _b = __values(regexp.flags.split('')), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var flag = _c.value;\n            if (!supportedJSFlags.has(flag)) {\n                throw new Error(\"Unsupported flag: \".concat(flag));\n            }\n            if (flag === 'u') {\n                unicode = true;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return isSafePattern(regexp.source, __assign(__assign({}, config), { unicode: unicode }));\n}\n\nexport { defaultMaxBacktracks, defaultMaxSteps, defaultResultsLimit, defaultTimeout, defaultUnicode, downgradePattern, isSafe, isSafePattern, toFriendly, version };\n","import { isSafe } from \"redos-detector\";\n\nconst checkForRedosError = (regex: string): any => {\n  return !isSafe(new RegExp(`${regex}`)).safe\n    ? [\n        {\n          message: `${regex} This pattern is not safe from ReDoS attacks.`,\n        },\n      ]\n    : [];\n};\n\nexport default checkForRedosError;\n","// import isNil = require(\"lodash/fp/isNil\");\nimport checkForRedosError from \"../shared/checkForRedosError\";\nimport {\n  createRulesetFunction,\n  IFunctionResult,\n} from \"@stoplight/spectral-core\";\n\nexport default createRulesetFunction(\n  { input: null, options: {} },\n  function validateSchemaPropertyPatternRegex(input: any): IFunctionResult[] {\n    if (input.pattern !== undefined || null) {\n      return checkForRedosError(input.pattern);\n    } else {\n      return [];\n    }\n  }\n);\n","var HttpParamStyles;\n(function (HttpParamStyles) {\n    HttpParamStyles[\"Simple\"] = \"simple\";\n    HttpParamStyles[\"Matrix\"] = \"matrix\";\n    HttpParamStyles[\"Label\"] = \"label\";\n    HttpParamStyles[\"Form\"] = \"form\";\n    HttpParamStyles[\"CommaDelimited\"] = \"commaDelimited\";\n    HttpParamStyles[\"SpaceDelimited\"] = \"spaceDelimited\";\n    HttpParamStyles[\"PipeDelimited\"] = \"pipeDelimited\";\n    HttpParamStyles[\"DeepObject\"] = \"deepObject\";\n})(HttpParamStyles || (HttpParamStyles = {}));\n\n/**\n * Represents the severity of diagnostics.\n */\nvar DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Something not allowed by the rules of a language or other means.\n     */\n    DiagnosticSeverity[DiagnosticSeverity[\"Error\"] = 0] = \"Error\";\n    /**\n     * Something suspicious but allowed.\n     */\n    DiagnosticSeverity[DiagnosticSeverity[\"Warning\"] = 1] = \"Warning\";\n    /**\n     * Something to inform about but not a problem.\n     */\n    DiagnosticSeverity[DiagnosticSeverity[\"Information\"] = 2] = \"Information\";\n    /**\n     * Something to hint to a better way of doing it, like proposing\n     * a refactoring.\n     */\n    DiagnosticSeverity[DiagnosticSeverity[\"Hint\"] = 3] = \"Hint\";\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n\n/**\n * Stoplight node types\n */\nvar NodeType;\n(function (NodeType) {\n    NodeType[\"Article\"] = \"article\";\n    NodeType[\"HttpService\"] = \"http_service\";\n    NodeType[\"HttpServer\"] = \"http_server\";\n    NodeType[\"HttpOperation\"] = \"http_operation\";\n    NodeType[\"Model\"] = \"model\";\n    NodeType[\"Generic\"] = \"generic\";\n    NodeType[\"Unknown\"] = \"unknown\";\n    NodeType[\"TableOfContents\"] = \"table_of_contents\";\n    NodeType[\"SpectralRuleset\"] = \"spectral_ruleset\";\n    NodeType[\"Styleguide\"] = \"styleguide\";\n    NodeType[\"Image\"] = \"image\";\n})(NodeType || (NodeType = {}));\n/**\n * Node data formats\n */\nvar NodeFormat;\n(function (NodeFormat) {\n    NodeFormat[\"Json\"] = \"json\";\n    NodeFormat[\"Markdown\"] = \"markdown\";\n    NodeFormat[\"Yaml\"] = \"yaml\";\n    NodeFormat[\"Javascript\"] = \"javascript\";\n    NodeFormat[\"Apng\"] = \"apng\";\n    NodeFormat[\"Avif\"] = \"avif\";\n    NodeFormat[\"Bmp\"] = \"bmp\";\n    NodeFormat[\"Gif\"] = \"gif\";\n    NodeFormat[\"Jpeg\"] = \"jpeg\";\n    NodeFormat[\"Png\"] = \"png\";\n    NodeFormat[\"Svg\"] = \"svg\";\n    NodeFormat[\"Webp\"] = \"webp\";\n})(NodeFormat || (NodeFormat = {}));\n\nexport { DiagnosticSeverity, HttpParamStyles, NodeFormat, NodeType };\n"],"mappings":"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","names":["__assign","module","fromCodePoint","parse","str","flags","match","pos","map","_a","offset","stackEntry","group","index","InfiniteLoopTracker","ResultCache","SidesEqualChecker","i","result","lastResult","needToRerun","_b","_a","HttpParamStyles","DiagnosticSeverity","NodeType","NodeFormat"]}